<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.13"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Utilities</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "color.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
});
MathJax.Hub.Config({
    tex2jax: {inlineMath: [['^^','^^'], ['\\(', '\\)']]}
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
      SpECTRE &#160;
        <span id="projectnumber">v0.0.0</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Documentation</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown" style="min-width: 150px;">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Reference</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div><!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of useful classes, functions and metafunctions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegsl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsl.html">gsl</a></td></tr>
<tr class="memdesc:namespacegsl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations from the Guideline Support Library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetmpl2"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetmpl2.html">tmpl2</a></td></tr>
<tr class="memdesc:namespacetmpl2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogramming things that are not planned to be submitted to Brigand. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInformer.html">Informer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classInformer.html" title="The Informer manages textual output regarding the status of a simulation. ">Informer</a> manages textual output regarding the status of a simulation.  <a href="classInformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDeferred.html">Deferred&lt; Rt &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides deferred or lazy evaluation of a function or function object, as well as efficient storage of an object that is mutable.  <a href="classDeferred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContinuedFraction.html">ContinuedFraction&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the continued fraction representation of a number.  <a href="classContinuedFraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContinuedFractionSummer.html">ContinuedFractionSummer&lt; Fraction &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum a continued fraction.  <a href="classContinuedFractionSummer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require a pointer to not be a <code>nullptr</code>  <a href="classgsl_1_1not__null.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNoSuchType.html">NoSuchType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to mark "no type" or "bad state" for metaprogramming.  <a href="structNoSuchType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOverloader.html">Overloader&lt; Fs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for overloading lambdas, useful for lambda-SFINAE.  <a href="classOverloader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPointerVector.html">PointerVector&lt; Type, AF, PF, TF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A raw pointer endowed with expression template support via the Blaze library.  <a href="structPointerVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt; Tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An associative container that is indexed by structs.  <a href="classtuples_1_1TaggedTuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtmpl2_1_1value__list.html">tmpl2::value_list&lt; T,... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time list of values of the same type.  <a href="structtmpl2_1_1value__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeDisplayer.html">TypeDisplayer&lt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get compiler error with type of template parameter.  <a href="structTypeDisplayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpp17_1_1void__type.html">cpp17::void_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a return type as being "void". In C++17 void is a regular type under certain circumstances, so this can be replaced by <code>void</code> then.  <a href="structcpp17_1_1void__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga265f35910bd218c59dd33acffe0c0b69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga265f35910bd218c59dd33acffe0c0b69">DEFINE_FAKE_VIRTUAL</a>(function)</td></tr>
<tr class="memdesc:ga265f35910bd218c59dd33acffe0c0b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function that acts similarly to a virtual function, but can take template parameters.  <a href="#ga265f35910bd218c59dd33acffe0c0b69">More...</a><br /></td></tr>
<tr class="separator:ga265f35910bd218c59dd33acffe0c0b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d571cd642604cb7bd87bb039ca3760f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga9d571cd642604cb7bd87bb039ca3760f">SPECTRE_ALWAYS_INLINE</a>&#160;&#160;&#160;inline</td></tr>
<tr class="memdesc:ga9d571cd642604cb7bd87bb039ca3760f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always inline a function. Only use this if you benchmarked the code.  <a href="#ga9d571cd642604cb7bd87bb039ca3760f">More...</a><br /></td></tr>
<tr class="separator:ga9d571cd642604cb7bd87bb039ca3760f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf62c1282f8b71500bbe2f4a4e945b66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaaf62c1282f8b71500bbe2f4a4e945b66">SPECTRE_JUST_ALWAYS_INLINE</a></td></tr>
<tr class="memdesc:gaaf62c1282f8b71500bbe2f4a4e945b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always inline a function, but do not mark it <code>inline</code>  <a href="#gaaf62c1282f8b71500bbe2f4a4e945b66">More...</a><br /></td></tr>
<tr class="separator:gaaf62c1282f8b71500bbe2f4a4e945b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b776398a66e9a6bd561c8decf08b47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATION_MACRO, ...)</td></tr>
<tr class="memdesc:gad7b776398a66e9a6bd561c8decf08b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro useful for generating many explicit instantiations of function or class templates.  <a href="#gad7b776398a66e9a6bd561c8decf08b47">More...</a><br /></td></tr>
<tr class="separator:gad7b776398a66e9a6bd561c8decf08b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffde14445f49f65ff4f5b592e44ee71a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaffde14445f49f65ff4f5b592e44ee71a">LIKELY</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="separator:gaffde14445f49f65ff4f5b592e44ee71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10d0a221f4d7a706701b806c8135fd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gab10d0a221f4d7a706701b806c8135fd7">UNLIKELY</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="separator:gab10d0a221f4d7a706701b806c8135fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf20b9d9f0e5870cc74c49bdf971e2cc6"><td class="memTemplParams" colspan="2">template&lt;typename Sequence &gt; </td></tr>
<tr class="memitem:gaf20b9d9f0e5870cc74c49bdf971e2cc6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaf20b9d9f0e5870cc74c49bdf971e2cc6">make_boost_variant_over</a> = typename detail::make_boost_variant_over_impl&lt; Sequence &gt;::type</td></tr>
<tr class="memdesc:gaf20b9d9f0e5870cc74c49bdf971e2cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a boost::variant with all all the types inside the typelist Sequence.  <a href="#gaf20b9d9f0e5870cc74c49bdf971e2cc6">More...</a><br /></td></tr>
<tr class="separator:gaf20b9d9f0e5870cc74c49bdf971e2cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084d535585c18d4e80f8ec6052d341a3"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:ga084d535585c18d4e80f8ec6052d341a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a> = typename Requires_detail::requires_impl&lt; B &gt;::template_error_type_failed_to_meet_requirements_on_template_parameters</td></tr>
<tr class="memdesc:ga084d535585c18d4e80f8ec6052d341a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Express requirements on the template parameters of a function or class, replaces <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code>  <a href="#ga084d535585c18d4e80f8ec6052d341a3">More...</a><br /></td></tr>
<tr class="separator:ga084d535585c18d4e80f8ec6052d341a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d33140d1e46af90392a957855ea2a83"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9d33140d1e46af90392a957855ea2a83"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga9d33140d1e46af90392a957855ea2a83">tuples::TaggedTupleTypelist</a> = typename TaggedTuple_detail::tagged_tuple_typelist_impl&lt; T &gt;::type</td></tr>
<tr class="separator:ga9d33140d1e46af90392a957855ea2a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dabf6319ff36d72095831fba701afc1"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga4dabf6319ff36d72095831fba701afc1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga4dabf6319ff36d72095831fba701afc1">typelist</a> = tmpl::list&lt; Ts... &gt;</td></tr>
<tr class="memdesc:ga4dabf6319ff36d72095831fba701afc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a typelist of types <code>Ts</code>.  <a href="#ga4dabf6319ff36d72095831fba701afc1">More...</a><br /></td></tr>
<tr class="separator:ga4dabf6319ff36d72095831fba701afc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ee1794935080949a6995ae7d5e08cc"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga01ee1794935080949a6995ae7d5e08cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga01ee1794935080949a6995ae7d5e08cc">tmpl2::flat_all</a> = <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool, Bs... &gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool,(static_cast&lt; void &gt;(Bs), true)... &gt; &gt;</td></tr>
<tr class="memdesc:ga01ee1794935080949a6995ae7d5e08cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical AND between bools 'B"".  <a href="group__Utilities.html#ga01ee1794935080949a6995ae7d5e08cc">More...</a><br /></td></tr>
<tr class="separator:ga01ee1794935080949a6995ae7d5e08cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga6e25dbfa539ff4513329969dbcd81c40">tmpl2::flat_any</a> = <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; bool, not <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool, Bs... &gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool,(static_cast&lt; void &gt;(Bs), false)... &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:ga6e25dbfa539ff4513329969dbcd81c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical OR between bools 'B"".  <a href="group__Utilities.html#ga6e25dbfa539ff4513329969dbcd81c40">More...</a><br /></td></tr>
<tr class="separator:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gada33ac747e1720e8d6c7d89323663c3e"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gada33ac747e1720e8d6c7d89323663c3e">info_from_build</a> ()</td></tr>
<tr class="memdesc:gada33ac747e1720e8d6c7d89323663c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the version, date, host, git commit, and link time.  <a href="#gada33ac747e1720e8d6c7d89323663c3e">More...</a><br /></td></tr>
<tr class="separator:gada33ac747e1720e8d6c7d89323663c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga440a175ca29c1e92a7147f210a860932"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga440a175ca29c1e92a7147f210a860932">spectre_version</a> ()</td></tr>
<tr class="memdesc:ga440a175ca29c1e92a7147f210a860932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a string containing the current version of SpECTRE.  <a href="#ga440a175ca29c1e92a7147f210a860932">More...</a><br /></td></tr>
<tr class="separator:ga440a175ca29c1e92a7147f210a860932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36b2bffa5f55447db8d65c1e045d626a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga36b2bffa5f55447db8d65c1e045d626a">spectre_major_version</a> ()</td></tr>
<tr class="memdesc:ga36b2bffa5f55447db8d65c1e045d626a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns major version.  <a href="#ga36b2bffa5f55447db8d65c1e045d626a">More...</a><br /></td></tr>
<tr class="separator:ga36b2bffa5f55447db8d65c1e045d626a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddcfc56ecb94ec0577388d27f7431bb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaddcfc56ecb94ec0577388d27f7431bb2">spectre_minor_version</a> ()</td></tr>
<tr class="memdesc:gaddcfc56ecb94ec0577388d27f7431bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns minor version.  <a href="#gaddcfc56ecb94ec0577388d27f7431bb2">More...</a><br /></td></tr>
<tr class="separator:gaddcfc56ecb94ec0577388d27f7431bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9158b176bca8b48872287187b6101250"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga9158b176bca8b48872287187b6101250">spectre_patch_version</a> ()</td></tr>
<tr class="memdesc:ga9158b176bca8b48872287187b6101250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns patch version.  <a href="#ga9158b176bca8b48872287187b6101250">More...</a><br /></td></tr>
<tr class="separator:ga9158b176bca8b48872287187b6101250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa46a305d87ee4ae9fede9d55c373286"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaaa46a305d87ee4ae9fede9d55c373286">ddot_</a> (const size_t &amp;N, const double *X, const size_t &amp;INCX, const double *Y, const size_t &amp;INCY)</td></tr>
<tr class="separator:gaaa46a305d87ee4ae9fede9d55c373286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa979e736ddfc838ddcba025a40a11469"><td class="memTemplParams" colspan="2">template&lt;typename Fp , typename... Args&gt; </td></tr>
<tr class="memitem:gaa979e736ddfc838ddcba025a40a11469"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDeferred.html">Deferred</a>&lt; Rt1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaa979e736ddfc838ddcba025a40a11469">make_deferred</a> (Fp f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaa979e736ddfc838ddcba025a40a11469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deferred function call object.  <a href="#gaa979e736ddfc838ddcba025a40a11469">More...</a><br /></td></tr>
<tr class="separator:gaa979e736ddfc838ddcba025a40a11469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaccb7d5132ccd60f32c504c51f9d7fb3c">dereference_wrapper</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reference object held by a reference wrapper, if a non-reference_wrapper type is passed in then the object is returned.  <a href="#gaccb7d5132ccd60f32c504c51f9d7fb3c">More...</a><br /></td></tr>
<tr class="separator:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c00908b8856ad6d441d443d22586d0a"><td class="memTemplParams" colspan="2">template&lt;typename Fraction , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga6c00908b8856ad6d441d443d22586d0a"><td class="memTemplItemLeft" align="right" valign="top">Fraction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga6c00908b8856ad6d441d443d22586d0a">simplest_fraction_in_interval</a> (const T1 &amp;end1, const T2 &amp;end2) noexcept</td></tr>
<tr class="memdesc:ga6c00908b8856ad6d441d443d22586d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the fraction in the supplied interval with the smallest denominator.  <a href="#ga6c00908b8856ad6d441d443d22586d0a">More...</a><br /></td></tr>
<tr class="separator:ga6c00908b8856ad6d441d443d22586d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga2da8b404f35c108209c4ce27c8d50e1c">gsl::narrow_cast</a> (U &amp;&amp;u) noexcept</td></tr>
<tr class="memdesc:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <code>u</code> to a type <code>T</code> where the cast may result in narrowing.  <a href="group__Utilities.html#ga2da8b404f35c108209c4ce27c8d50e1c">More...</a><br /></td></tr>
<tr class="separator:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gafaf6db75ede2a9bc2fa4b6b17b8ef128">gsl::narrow</a> (U u)</td></tr>
<tr class="memdesc:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="mdescLeft">&#160;</td><td class="mdescRight">A checked version of <a class="el" href="group__Utilities.html#ga2da8b404f35c108209c4ce27c8d50e1c" title="Cast u to a type T where the cast may result in narrowing. ">narrow_cast()</a> that ERRORs if the cast changed the value.  <a href="group__Utilities.html#gafaf6db75ede2a9bc2fa4b6b17b8ef128">More...</a><br /></td></tr>
<tr class="separator:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c127d07f412267ea6548c8dab8b44c1"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga9c127d07f412267ea6548c8dab8b44c1">operator&quot;&quot; _st</a> (const unsigned long long n)</td></tr>
<tr class="memdesc:ga9c127d07f412267ea6548c8dab8b44c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the _st size_t suffix.  <a href="#ga9c127d07f412267ea6548c8dab8b44c1">More...</a><br /></td></tr>
<tr class="separator:ga9c127d07f412267ea6548c8dab8b44c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6dc63579cfb3cb3a49db1945ec0fe6"><td class="memTemplParams" colspan="2">template&lt;std::size_t size, typename T &gt; </td></tr>
<tr class="memitem:gadf6dc63579cfb3cb3a49db1945ec0fe6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;, size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gadf6dc63579cfb3cb3a49db1945ec0fe6">make_array</a> (T &amp;&amp;value) noexcept(noexcept(make_array(<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a>, size &gt;{}, std::forward&lt; T &gt;(value))))</td></tr>
<tr class="memdesc:gadf6dc63579cfb3cb3a49db1945ec0fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to initialize a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>.  <a href="#gadf6dc63579cfb3cb3a49db1945ec0fe6">More...</a><br /></td></tr>
<tr class="separator:gadf6dc63579cfb3cb3a49db1945ec0fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f579d55a04631539629be19103dcae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... V, Requires&lt;(sizeof...(V) &gt; 0&gt; </td></tr>
<tr class="memitem:ga18f579d55a04631539629be19103dcae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; typename <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;, sizeof...(V)+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga18f579d55a04631539629be19103dcae">make_array</a> (T &amp;&amp;t, V &amp;&amp;... values) noexcept(noexcept(<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;, sizeof...(V)+1 &gt;{ {std::forward&lt; T &gt;(t), std::forward&lt; V &gt;(values)...}}))</td></tr>
<tr class="memdesc:ga18f579d55a04631539629be19103dcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to initialize a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a> with varying number of arguments.  <a href="#ga18f579d55a04631539629be19103dcae">More...</a><br /></td></tr>
<tr class="separator:ga18f579d55a04631539629be19103dcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea51ad2c5ef8f8f99279545e1389d056"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t size, typename Seq &gt; </td></tr>
<tr class="memitem:gaea51ad2c5ef8f8f99279545e1389d056"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaea51ad2c5ef8f8f99279545e1389d056">make_array</a> (Seq &amp;&amp;seq) noexcept(noexcept(MakeArray_detail::make_array_from_iterator_impl&lt; T, size &gt;(std::forward&lt; Seq &gt;(seq), <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; size &gt;{})))</td></tr>
<tr class="memdesc:gaea51ad2c5ef8f8f99279545e1389d056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, size&gt;</code> from the first <code>size</code> values of <code>seq</code>  <a href="#gaea51ad2c5ef8f8f99279545e1389d056">More...</a><br /></td></tr>
<tr class="separator:gaea51ad2c5ef8f8f99279545e1389d056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eed7cb45692393b257c3987070d1da2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1eed7cb45692393b257c3987070d1da2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga1eed7cb45692393b257c3987070d1da2">number_of_digits</a> (const T number)</td></tr>
<tr class="memdesc:ga1eed7cb45692393b257c3987070d1da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of digits in an integer number.  <a href="#ga1eed7cb45692393b257c3987070d1da2">More...</a><br /></td></tr>
<tr class="separator:ga1eed7cb45692393b257c3987070d1da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87825ee8984324e81a2ae6ab2fec6ed"><td class="memTemplParams" colspan="2">template&lt;class... Fs&gt; </td></tr>
<tr class="memitem:gad87825ee8984324e81a2ae6ab2fec6ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Overloader_8hpp.html#a3f27d4abd722fa18956ccdcf32602a2a">OVERLOADER_CONSTEXPR</a> <a class="el" href="classOverloader.html">Overloader</a>&lt; Fs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gad87825ee8984324e81a2ae6ab2fec6ed">make_overloader</a> (Fs... fs)</td></tr>
<tr class="memdesc:gad87825ee8984324e81a2ae6ab2fec6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <code><a class="el" href="classOverloader.html" title="Used for overloading lambdas, useful for lambda-SFINAE. ">Overloader</a>&lt;Fs...&gt;</code>, see <a class="el" href="classOverloader.html" title="Used for overloading lambdas, useful for lambda-SFINAE. ">Overloader</a> for details.  <a href="#gad87825ee8984324e81a2ae6ab2fec6ed">More...</a><br /></td></tr>
<tr class="separator:gad87825ee8984324e81a2ae6ab2fec6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49015243242c2caad5bdbd64ea7449a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga49015243242c2caad5bdbd64ea7449a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga49015243242c2caad5bdbd64ea7449a1">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga49015243242c2caad5bdbd64ea7449a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.  <a href="#ga49015243242c2caad5bdbd64ea7449a1">More...</a><br /></td></tr>
<tr class="separator:ga49015243242c2caad5bdbd64ea7449a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b8db62a17e01a839e499a4c59112df5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4b8db62a17e01a839e499a4c59112df5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga4b8db62a17e01a839e499a4c59112df5">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga4b8db62a17e01a839e499a4c59112df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>.  <a href="#ga4b8db62a17e01a839e499a4c59112df5">More...</a><br /></td></tr>
<tr class="separator:ga4b8db62a17e01a839e499a4c59112df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3acb5ffe1cdbc6f9fb1a506584f8f132"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3acb5ffe1cdbc6f9fb1a506584f8f132"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga3acb5ffe1cdbc6f9fb1a506584f8f132">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga3acb5ffe1cdbc6f9fb1a506584f8f132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>.  <a href="#ga3acb5ffe1cdbc6f9fb1a506584f8f132">More...</a><br /></td></tr>
<tr class="separator:ga3acb5ffe1cdbc6f9fb1a506584f8f132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ca1c2d4ff05b9b2d683f207d58be92"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ga85ca1c2d4ff05b9b2d683f207d58be92"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga85ca1c2d4ff05b9b2d683f207d58be92">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:ga85ca1c2d4ff05b9b2d683f207d58be92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>.  <a href="#ga85ca1c2d4ff05b9b2d683f207d58be92">More...</a><br /></td></tr>
<tr class="separator:ga85ca1c2d4ff05b9b2d683f207d58be92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81330e34bc91cfbd33c4d5272d33c53b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga81330e34bc91cfbd33c4d5272d33c53b"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga81330e34bc91cfbd33c4d5272d33c53b">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Args... &gt; &amp;t)</td></tr>
<tr class="memdesc:ga81330e34bc91cfbd33c4d5272d33c53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for tuples.  <a href="#ga81330e34bc91cfbd33c4d5272d33c53b">More...</a><br /></td></tr>
<tr class="separator:ga81330e34bc91cfbd33c4d5272d33c53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa1563de19d53297daf7861a5170f2f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename H &gt; </td></tr>
<tr class="memitem:gadaa1563de19d53297daf7861a5170f2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gadaa1563de19d53297daf7861a5170f2f">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; K, V, H &gt; &amp;m)</td></tr>
<tr class="memdesc:gadaa1563de19d53297daf7861a5170f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output all the key, value pairs of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>.  <a href="#gadaa1563de19d53297daf7861a5170f2f">More...</a><br /></td></tr>
<tr class="separator:gadaa1563de19d53297daf7861a5170f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8b69f709871a3517de357ffaec062e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename C &gt; </td></tr>
<tr class="memitem:gaaa8b69f709871a3517de357ffaec062e"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaaa8b69f709871a3517de357ffaec062e">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:gaaa8b69f709871a3517de357ffaec062e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output all the key, value pairs of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>.  <a href="#gaaa8b69f709871a3517de357ffaec062e">More...</a><br /></td></tr>
<tr class="separator:gaaa8b69f709871a3517de357ffaec062e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf389850e8ebc7d8040dfb5a50036f0ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf389850e8ebc7d8040dfb5a50036f0ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaf389850e8ebc7d8040dfb5a50036f0ee">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:gaf389850e8ebc7d8040dfb5a50036f0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>.  <a href="#gaf389850e8ebc7d8040dfb5a50036f0ee">More...</a><br /></td></tr>
<tr class="separator:gaf389850e8ebc7d8040dfb5a50036f0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23e067621bfcb4fcef006fd36b1a2909"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C &gt; </td></tr>
<tr class="memitem:ga23e067621bfcb4fcef006fd36b1a2909"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga23e067621bfcb4fcef006fd36b1a2909">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt; T, C &gt; &amp;v)</td></tr>
<tr class="memdesc:ga23e067621bfcb4fcef006fd36b1a2909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>.  <a href="#ga23e067621bfcb4fcef006fd36b1a2909">More...</a><br /></td></tr>
<tr class="separator:ga23e067621bfcb4fcef006fd36b1a2909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4affaa7af20b9ab232a5cae60d1fd5"><td class="memTemplParams" colspan="2">template&lt;typename T , Requires&lt; tt::is_streamable&lt; std::ostream, T &gt;::value &gt; &gt; </td></tr>
<tr class="memitem:ga5a4affaa7af20b9ab232a5cae60d1fd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga5a4affaa7af20b9ab232a5cae60d1fd5">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga5a4affaa7af20b9ab232a5cae60d1fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>.  <a href="#ga5a4affaa7af20b9ab232a5cae60d1fd5">More...</a><br /></td></tr>
<tr class="separator:ga5a4affaa7af20b9ab232a5cae60d1fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d6a6a95d4ebc4e5fca330a272a6182"><td class="memTemplParams" colspan="2">template&lt;typename T , Requires&lt; tt::is_streamable&lt; std::ostream, T &gt;::value &gt; &gt; </td></tr>
<tr class="memitem:ga78d6a6a95d4ebc4e5fca330a272a6182"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga78d6a6a95d4ebc4e5fca330a272a6182">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga78d6a6a95d4ebc4e5fca330a272a6182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>.  <a href="#ga78d6a6a95d4ebc4e5fca330a272a6182">More...</a><br /></td></tr>
<tr class="separator:ga78d6a6a95d4ebc4e5fca330a272a6182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcbd91b985044319a768092b12cd5045"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gadcbd91b985044319a768092b12cd5045"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gadcbd91b985044319a768092b12cd5045">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; T, U &gt; &amp;t)</td></tr>
<tr class="memdesc:gadcbd91b985044319a768092b12cd5045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>.  <a href="#gadcbd91b985044319a768092b12cd5045">More...</a><br /></td></tr>
<tr class="separator:gadcbd91b985044319a768092b12cd5045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495b431a620b10beb24f1afc90b77e20"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename H &gt; </td></tr>
<tr class="memitem:ga495b431a620b10beb24f1afc90b77e20"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga495b431a620b10beb24f1afc90b77e20">keys_of</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; K, V, H &gt; &amp;m)</td></tr>
<tr class="memdesc:ga495b431a620b10beb24f1afc90b77e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string containing the keys of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>.  <a href="#ga495b431a620b10beb24f1afc90b77e20">More...</a><br /></td></tr>
<tr class="separator:ga495b431a620b10beb24f1afc90b77e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf707b57628e9425c91d92eb278a52c99"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename C &gt; </td></tr>
<tr class="memitem:gaf707b57628e9425c91d92eb278a52c99"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaf707b57628e9425c91d92eb278a52c99">keys_of</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:gaf707b57628e9425c91d92eb278a52c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string containing the keys of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>.  <a href="#gaf707b57628e9425c91d92eb278a52c99">More...</a><br /></td></tr>
<tr class="separator:gaf707b57628e9425c91d92eb278a52c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga9a7c7ee897f581360154a3676d5f7ab9">formatted_string</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;fmt, Args... args)</td></tr>
<tr class="memdesc:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a string like printf.  <a href="#ga9a7c7ee897f581360154a3676d5f7ab9">More...</a><br /></td></tr>
<tr class="separator:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaa9e9df95875a2fa4b6ec2acfe7fa26ff">current_date_and_time</a> ()</td></tr>
<tr class="memdesc:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current date and time.  <a href="#gaa9e9df95875a2fa4b6ec2acfe7fa26ff">More...</a><br /></td></tr>
<tr class="separator:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcdd6af307bde8b3bf0650395c9768a7"><td class="memTemplParams" colspan="2">template&lt;size_t ElementToRemove, typename T , size_t Dim&gt; </td></tr>
<tr class="memitem:gadcdd6af307bde8b3bf0650395c9768a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gadcdd6af307bde8b3bf0650395c9768a7">all_but_specified_element_of</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:gadcdd6af307bde8b3bf0650395c9768a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from an existing array omitting one element.  <a href="#gadcdd6af307bde8b3bf0650395c9768a7">More...</a><br /></td></tr>
<tr class="separator:gadcdd6af307bde8b3bf0650395c9768a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b6ade329d6c1dbce2c67a94a58b2304"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga8b6ade329d6c1dbce2c67a94a58b2304"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga8b6ade329d6c1dbce2c67a94a58b2304">swallow</a> (Ts &amp;&amp;...) noexcept</td></tr>
<tr class="memdesc:ga8b6ade329d6c1dbce2c67a94a58b2304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows zero-cost unordered expansion of a parameter.  <a href="#ga8b6ade329d6c1dbce2c67a94a58b2304">More...</a><br /></td></tr>
<tr class="separator:ga8b6ade329d6c1dbce2c67a94a58b2304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65147320c04e61267089a58d71a6302"><td class="memTemplParams" colspan="2">template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </td></tr>
<tr class="memitem:gad65147320c04e61267089a58d71a6302"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gad65147320c04e61267089a58d71a6302">tuple_transform</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args) noexcept(noexcept(tuple_impl_detail::tuple_transform_impl&lt; ReverseIteration &gt;(tuple, std::forward&lt; N_aryOp &gt;(op), <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; sizeof...(Elements)&gt;{}, args...)))</td></tr>
<tr class="memdesc:gad65147320c04e61267089a58d71a6302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a transform over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>.  <a href="#gad65147320c04e61267089a58d71a6302">More...</a><br /></td></tr>
<tr class="separator:gad65147320c04e61267089a58d71a6302"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab78389fadf763e3693ce893fad5d7fba"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:gab78389fadf763e3693ce893fad5d7fba"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gab78389fadf763e3693ce893fad5d7fba">tmpl2::flat_all_v</a> = <a class="el" href="group__Utilities.html#ga01ee1794935080949a6995ae7d5e08cc">flat_all</a>&lt;Bs...&gt;::value</td></tr>
<tr class="memdesc:gab78389fadf763e3693ce893fad5d7fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical AND between bools 'B"".  <a href="group__Utilities.html#gab78389fadf763e3693ce893fad5d7fba">More...</a><br /></td></tr>
<tr class="separator:gab78389fadf763e3693ce893fad5d7fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga8a328cb983ebb1947b0eb9d924f40253">tmpl2::flat_any_v</a> = <a class="el" href="group__Utilities.html#ga6e25dbfa539ff4513329969dbcd81c40">flat_any</a>&lt;Bs...&gt;::value</td></tr>
<tr class="memdesc:ga8a328cb983ebb1947b0eb9d924f40253"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical OR between bools 'B"".  <a href="group__Utilities.html#ga8a328cb983ebb1947b0eb9d924f40253">More...</a><br /></td></tr>
<tr class="separator:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac932a44b57087d32ce5341314437dbbd"><td class="memTemplParams" colspan="2">template&lt;bool UseLibXsmm = false&gt; </td></tr>
<tr class="memitem:gac932a44b57087d32ce5341314437dbbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gac932a44b57087d32ce5341314437dbbd">dgemm_</a> (const char &amp;TRANSA, const char &amp;TRANSB, const size_t &amp;M, const size_t &amp;N, const size_t &amp;K, const double &amp;ALPHA, const double *A, const size_t &amp;LDA, const double *B, const size_t &amp;LDB, const double &amp;BETA, double *C, const size_t &amp;LDC)</td></tr>
<tr class="memdesc:gac932a44b57087d32ce5341314437dbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a matrix-matrix multiplication.  <a href="#gac932a44b57087d32ce5341314437dbbd">More...</a><br /></td></tr>
<tr class="separator:gac932a44b57087d32ce5341314437dbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaba62a62589ffc7b8b85a7722390f7ce0">dgemm_&lt; true &gt;</a> (const char &amp;TRANSA, const char &amp;TRANSB, const size_t &amp;M, const size_t &amp;N, const size_t &amp;K, const double &amp;ALPHA, const double *A, const size_t &amp;LDA, const double *B, const size_t &amp;LDB, const double &amp;BETA, double *C, const size_t &amp;LDC)</td></tr>
<tr class="memdesc:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a matrix-matrix multiplication.  <a href="#gaba62a62589ffc7b8b85a7722390f7ce0">More...</a><br /></td></tr>
<tr class="separator:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d31316e0975f0a66a60d9ac92756a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gad4d31316e0975f0a66a60d9ac92756a8">dgemv_</a> (const char &amp;TRANS, const size_t &amp;M, const size_t &amp;N, const double &amp;ALPHA, const double *A, const size_t &amp;LDA, const double *X, const size_t &amp;INCX, const double &amp;BETA, double *Y, const size_t &amp;INCY)</td></tr>
<tr class="memdesc:gad4d31316e0975f0a66a60d9ac92756a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a matrix-vector multiplication.  <a href="#gad4d31316e0975f0a66a60d9ac92756a8">More...</a><br /></td></tr>
<tr class="separator:gad4d31316e0975f0a66a60d9ac92756a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N, typename Size &gt; </td></tr>
<tr class="memitem:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga818f101f2f8bd824a3bc7c2c2361c560">gsl::at</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, N &gt; &amp;arr, Size index)</td></tr>
<tr class="memdesc:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid.  <a href="group__Utilities.html#ga818f101f2f8bd824a3bc7c2c2361c560">More...</a><br /></td></tr>
<tr class="separator:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1648d283e2a226cd398dbea1de84e88d"><td class="memTemplParams" colspan="2">template&lt;class Cont , typename Size &gt; </td></tr>
<tr class="memitem:ga1648d283e2a226cd398dbea1de84e88d"><td class="memTemplItemLeft" align="right" valign="top">constexpr const Cont::value_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga1648d283e2a226cd398dbea1de84e88d">gsl::at</a> (const Cont &amp;cont, Size index)</td></tr>
<tr class="memdesc:ga1648d283e2a226cd398dbea1de84e88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid.  <a href="group__Utilities.html#ga1648d283e2a226cd398dbea1de84e88d">More...</a><br /></td></tr>
<tr class="separator:ga1648d283e2a226cd398dbea1de84e88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac75622e2034e12763b1e3989b813376b"><td class="memTemplParams" colspan="2">template&lt;class T , typename Size &gt; </td></tr>
<tr class="memitem:gac75622e2034e12763b1e3989b813376b"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gac75622e2034e12763b1e3989b813376b">gsl::at</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; T &gt; cont, Size index)</td></tr>
<tr class="memdesc:gac75622e2034e12763b1e3989b813376b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid.  <a href="group__Utilities.html#gac75622e2034e12763b1e3989b813376b">More...</a><br /></td></tr>
<tr class="separator:gac75622e2034e12763b1e3989b813376b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce4f7246dc4ad64d76817b8a988c056"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0ce4f7246dc4ad64d76817b8a988c056"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga0ce4f7246dc4ad64d76817b8a988c056">magnitude</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 1 &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga0ce4f7246dc4ad64d76817b8a988c056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="#ga0ce4f7246dc4ad64d76817b8a988c056">More...</a><br /></td></tr>
<tr class="separator:ga0ce4f7246dc4ad64d76817b8a988c056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d02f46cab8bbf00abc56508746cafde"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga2d02f46cab8bbf00abc56508746cafde"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga2d02f46cab8bbf00abc56508746cafde">magnitude</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 1 &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga2d02f46cab8bbf00abc56508746cafde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="#ga2d02f46cab8bbf00abc56508746cafde">More...</a><br /></td></tr>
<tr class="separator:ga2d02f46cab8bbf00abc56508746cafde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd04562712892d6d8f77ff26e9646a19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacd04562712892d6d8f77ff26e9646a19"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gacd04562712892d6d8f77ff26e9646a19">magnitude</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 2 &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:gacd04562712892d6d8f77ff26e9646a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="#gacd04562712892d6d8f77ff26e9646a19">More...</a><br /></td></tr>
<tr class="separator:gacd04562712892d6d8f77ff26e9646a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae942ed628d83d2f9dbf39a06f2996395"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae942ed628d83d2f9dbf39a06f2996395"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gae942ed628d83d2f9dbf39a06f2996395">magnitude</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:gae942ed628d83d2f9dbf39a06f2996395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="#gae942ed628d83d2f9dbf39a06f2996395">More...</a><br /></td></tr>
<tr class="separator:gae942ed628d83d2f9dbf39a06f2996395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="memTemplParams" colspan="2">template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="memTemplItemLeft" align="right" valign="top">constexpr const Tag::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaf29c2fe540b02e47a11c1ff9287bf169">tuples::get</a> (const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;t) noexcept</td></tr>
<tr class="memdesc:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>.  <a href="group__Utilities.html#gaf29c2fe540b02e47a11c1ff9287bf169">More...</a><br /></td></tr>
<tr class="separator:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0295bce7da8fd1957eecb2e0f31566a"><td class="memTemplParams" colspan="2">template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:gaa0295bce7da8fd1957eecb2e0f31566a"><td class="memTemplItemLeft" align="right" valign="top">constexpr Tag::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaa0295bce7da8fd1957eecb2e0f31566a">tuples::get</a> (<a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;t) noexcept</td></tr>
<tr class="memdesc:gaa0295bce7da8fd1957eecb2e0f31566a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>.  <a href="group__Utilities.html#gaa0295bce7da8fd1957eecb2e0f31566a">More...</a><br /></td></tr>
<tr class="separator:gaa0295bce7da8fd1957eecb2e0f31566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b1f97e933f2b274b8b7f2d4e92ec32e"><td class="memTemplParams" colspan="2">template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:ga3b1f97e933f2b274b8b7f2d4e92ec32e"><td class="memTemplItemLeft" align="right" valign="top">constexpr const Tag::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga3b1f97e933f2b274b8b7f2d4e92ec32e">tuples::get</a> (const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:ga3b1f97e933f2b274b8b7f2d4e92ec32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>.  <a href="group__Utilities.html#ga3b1f97e933f2b274b8b7f2d4e92ec32e">More...</a><br /></td></tr>
<tr class="separator:ga3b1f97e933f2b274b8b7f2d4e92ec32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30114b7db6af87e7e06e3ea6bac687eb"><td class="memTemplParams" colspan="2">template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:ga30114b7db6af87e7e06e3ea6bac687eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr Tag::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga30114b7db6af87e7e06e3ea6bac687eb">tuples::get</a> (<a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:ga30114b7db6af87e7e06e3ea6bac687eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>.  <a href="group__Utilities.html#ga30114b7db6af87e7e06e3ea6bac687eb">More...</a><br /></td></tr>
<tr class="separator:ga30114b7db6af87e7e06e3ea6bac687eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91227dc4aa14972b7b2e7070719d061b"><td class="memTemplParams" colspan="2">template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </td></tr>
<tr class="memitem:ga91227dc4aa14972b7b2e7070719d061b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args) noexcept(noexcept(tuple_impl_detail::tuple_fold_impl&lt; ReverseIteration &gt;(tuple, std::forward&lt; N_aryOp &gt;(op), <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; sizeof...(Elements)&gt;{}, args...)))</td></tr>
<tr class="memdesc:ga91227dc4aa14972b7b2e7070719d061b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>.  <a href="#ga91227dc4aa14972b7b2e7070719d061b">More...</a><br /></td></tr>
<tr class="separator:ga91227dc4aa14972b7b2e7070719d061b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f67981c777b6762ada9da5ad5da11e7"><td class="memTemplParams" colspan="2">template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </td></tr>
<tr class="memitem:ga3f67981c777b6762ada9da5ad5da11e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga3f67981c777b6762ada9da5ad5da11e7">tuple_counted_fold</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args) noexcept(noexcept(tuple_impl_detail::tuple_counted_fold_impl&lt; ReverseIteration &gt;(tuple, std::forward&lt; N_aryOp &gt;(op), <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; sizeof...(Elements)&gt;{}, args...)))</td></tr>
<tr class="memdesc:ga3f67981c777b6762ada9da5ad5da11e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>.  <a href="#ga3f67981c777b6762ada9da5ad5da11e7">More...</a><br /></td></tr>
<tr class="separator:ga3f67981c777b6762ada9da5ad5da11e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A collection of useful classes, functions and metafunctions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga265f35910bd218c59dd33acffe0c0b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga265f35910bd218c59dd33acffe0c0b69">&#9670;&nbsp;</a></span>DEFINE_FAKE_VIRTUAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_FAKE_VIRTUAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a function that acts similarly to a virtual function, but can take template parameters. </p>
<h3>Details</h3>
<p><code><a class="el" href="group__Utilities.html#ga265f35910bd218c59dd33acffe0c0b69" title="Define a function that acts similarly to a virtual function, but can take template parameters...">DEFINE_FAKE_VIRTUAL(func)</a></code> defines the function <code>fake_virtual_func</code> and the struct <code>FakeVirtualInherit_func</code>. It should usually be called in a detail namespace.</p>
<p>A base class <code>Base</code> using this functionality should define a type </p><div class="fragment"><div class="line"><span class="keyword">using</span> Inherit = FakeVirtualInherit_func&lt;Base&gt;;</div></div><!-- fragment --><p> and a member function <code>func</code> wrapping <code>fake_virtual_func</code>, with the wrapper passing the derived classes as a typelist as the first template argument and the <code>this</code> pointer as the first normal argument.</p>
<p>Derived classes should then inherit from <code>Base::Inherit</code> instead of directly from <code>Base</code>. (<code>Base::Inherit</code> inherits from <code>Base</code>.)</p>
<p>If the base class has no pure virtual functions remaining it will generally be desirable to mark the constructors and assignment operators protected so that a bare base class cannot be instantiated.</p>
<p>If it is necessary to use multiple fake virtual functions with the same base class, the <code>Inherit</code> definition can nest the fake virtual classes: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Inherit = FakeVirtualInherit_func1&lt;FakeVirtualInherit_func2&lt;Base&gt;&gt;;</div></div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line"><a class="code" href="group__Utilities.html#ga265f35910bd218c59dd33acffe0c0b69">DEFINE_FAKE_VIRTUAL</a>(fv)</div><div class="line"></div><div class="line"><span class="keyword">class </span>Derived;</div><div class="line"></div><div class="line"><span class="keyword">class </span>Base {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> Inherit = FakeVirtualInherit_fv&lt;Base&gt;;</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  Base() = <span class="keywordflow">default</span>;</div><div class="line">  Base(<span class="keyword">const</span> Base&amp;) = <span class="keywordflow">default</span>;</div><div class="line">  Base(Base&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">  Base&amp; operator=(<span class="keyword">const</span> Base&amp;) = <span class="keywordflow">default</span>;</div><div class="line">  Base&amp; operator=(Base&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">  <span class="keywordtype">int</span> fv(<span class="keywordtype">int</span> x) {</div><div class="line">    <span class="keywordflow">return</span> fake_virtual_fv&lt;typelist&lt;Derived&gt;, T&gt;(<span class="keyword">this</span>, x);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Derived : <span class="keyword">public</span> Base::Inherit {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">  <span class="keywordtype">int</span> fv(<span class="keywordtype">int</span> x) {</div><div class="line">    <span class="keywordflow">return</span> x + 3;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment -->
</div>
</div>
<a id="gad7b776398a66e9a6bd561c8decf08b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b776398a66e9a6bd561c8decf08b47">&#9670;&nbsp;</a></span>GENERATE_INSTANTIATIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GENERATE_INSTANTIATIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">INSTANTIATION_MACRO, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">GENERATE_INSTANTIATIONS_DO_PRODUCT(                                    \</div><div class="line">      INSTANTIATION_MACRO,                                               \</div><div class="line">      BOOST_PP_LIST_TRANSFORM(GENERATE_INSTANTIATION_TUPLES_TO_LISTS, _, \</div><div class="line">                              BOOST_PP_VARIADIC_TO_LIST(__VA_ARGS__)))</div></div><!-- fragment -->
<p>Macro useful for generating many explicit instantiations of function or class templates. </p>
<p>It is often necessary to generate explicit instantiations of function or class templates. Since the total number of explicit instantiations scales as the product of the number of possible number of parameter values of each template parameter, this quickly becomes tedious. This macro allows you to easily generate hundreds of explicit instantiations.</p>
<p>The first argument to the macro is a macro that takes two arguments and is described below. The remaining arguments are macro-tuples, e.g. <code>(1, 2, 3)</code>. The Cartesian product of the macro-tuples is then computed and each term is passed as a tuple as the second argument to the <code>INSTANTIATION_MACRO</code>. The first argument to the <code>INSTANTIATION_MACRO</code> is a Boost.Preprocessor internal variable so just make it <code>_</code>. The <code><a class="el" href="DebugPreprocessor_8cpp.html#a95d9e1c448085436b88ab7063baae130">INSTANTIATION(_, data)</a></code> macro below serves as an example. A concrete example is generating explicit instantiations of the class <code><a class="el" href="classIndex.html" title="An integer multi-index. ">Index</a>&lt;Dim&gt;</code> for <code>Dim = 0,1,2,3</code>, which you would do as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define GET_DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define INSTANTIATION(_, data)         \</span></div><div class="line"><span class="preprocessor">  template class Index&lt;GET_DIM(data)&gt;;</span></div><div class="line"></div><div class="line"><a class="code" href="group__Utilities.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(<a class="code" href="DebugPreprocessor_8cpp.html#a95d9e1c448085436b88ab7063baae130">INSTANTIATION</a>, (0, 1, 2, 3))</div><div class="line"></div><div class="line"><span class="preprocessor">#undef GET_DIM</span></div><div class="line"><span class="preprocessor">#undef INSTANTIATION</span></div></div><!-- fragment --><p>This will generate:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;0&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;1&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;2&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;3&gt;</a>;</div></div><!-- fragment --><p>It is also possible to generate explicit instantiations for multiple classes or functions in a single call to <code>GENERATE_INSTANTIATIONS</code>. For example, the (in)equivalence operators can be generated using:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define GET_DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div><div class="line"><span class="preprocessor">#define GEN_OP(op, dim)                            \</span></div><div class="line"><span class="preprocessor">  template bool operator op(const Index&lt;dim&gt;&amp; lhs, \</span></div><div class="line"><span class="preprocessor">                            const Index&lt;dim&gt;&amp; rhs) noexcept;</span></div><div class="line"><span class="preprocessor">#define INSTANTIATION(_, data)         \</span></div><div class="line"><span class="preprocessor">  template class Index&lt;GET_DIM(data)&gt;; \</span></div><div class="line"><span class="preprocessor">  GEN_OP(==, GET_DIM(data))            \</span></div><div class="line"><span class="preprocessor">  GEN_OP(!=, GET_DIM(data))</span></div><div class="line"></div><div class="line"><a class="code" href="group__Utilities.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(<a class="code" href="DebugPreprocessor_8cpp.html#a95d9e1c448085436b88ab7063baae130">INSTANTIATION</a>, (0, 1, 2, 3))</div><div class="line"></div><div class="line"><span class="preprocessor">#undef GET_DIM</span></div><div class="line"><span class="preprocessor">#undef GEN_OP</span></div><div class="line"><span class="preprocessor">#undef INSTANTIATION</span></div></div><!-- fragment --><p>which will result in the instantiations:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;0&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code" href="SpherepackIterator_8hpp.html#aae5648f06d82c7fa07da8a67a2e1e69d">operator==</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code" href="SpherepackIterator_8hpp.html#a71ea7953aeaa3cc67867d18abf099455">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;1&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code" href="SpherepackIterator_8hpp.html#aae5648f06d82c7fa07da8a67a2e1e69d">operator==</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code" href="SpherepackIterator_8hpp.html#a71ea7953aeaa3cc67867d18abf099455">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;2&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code" href="SpherepackIterator_8hpp.html#aae5648f06d82c7fa07da8a67a2e1e69d">operator==</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code" href="SpherepackIterator_8hpp.html#a71ea7953aeaa3cc67867d18abf099455">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;3&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code" href="SpherepackIterator_8hpp.html#aae5648f06d82c7fa07da8a67a2e1e69d">operator==</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code" href="SpherepackIterator_8hpp.html#a71ea7953aeaa3cc67867d18abf099455">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; rhs) noexcept;</div></div><!-- fragment --><p>Now let's look at generating instantiations of member function templates of class templates, which will be a common use case. In this example we generate explicit instantiations of all the member function templates of the class <code><a class="el" href="classScalarWave_1_1Solutions_1_1PlaneWave.html" title="A plane wave solution to the Euclidean wave equation. ">ScalarWave::Solutions::PlaneWave</a></code>. In total, for <code>Dim = 1,2,3</code> and types <code>double</code> and <code><a class="el" href="classDataVector.html" title="A class for storing data on a mesh. ">DataVector</a></code> this is about 42 explicit instantiations, which would be extremely annoying to write by hand. The macro code is surprisingly simple:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div><div class="line"><span class="preprocessor">#define DTYPE(data) BOOST_PP_TUPLE_ELEM(1, data)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define INSTANTIATE(_, data)                                              \</span></div><div class="line"><span class="preprocessor">  template Scalar&lt;DTYPE(data)&gt;                                            \</span></div><div class="line"><span class="preprocessor">  ScalarWave::Solutions::PlaneWave&lt;DIM(data)&gt;::psi(                       \</span></div><div class="line"><span class="preprocessor">      const tnsr::I&lt;DTYPE(data), DIM(data)&gt;&amp; x, double t) const noexcept; \</span></div><div class="line"><span class="preprocessor">  template Scalar&lt;DTYPE(data)&gt;                                            \</span></div><div class="line"><span class="preprocessor">  ScalarWave::Solutions::PlaneWave&lt;DIM(data)&gt;::dpsi_dt(                   \</span></div><div class="line"><span class="preprocessor">      const tnsr::I&lt;DTYPE(data), DIM(data)&gt;&amp; x, double t) const noexcept;</span></div><div class="line"></div><div class="line"><a class="code" href="group__Utilities.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATE, (1, 2, 3), (<span class="keywordtype">double</span>, <a class="code" href="classDataVector.html">DataVector</a>))</div><div class="line"></div><div class="line"><span class="preprocessor">#undef DIM</span></div><div class="line"><span class="preprocessor">#undef DTYPE</span></div><div class="line"><span class="preprocessor">#undef INSTANTIATE</span></div></div><!-- fragment --><p>We don't show the result from preprocessor since for all of the member functions of <code>PlaneWave</code> the total output is approximately 150 lines, but you can hopefully see the benefits of generating explicit instantiations using the <code>GENERATE_INSTANTIATIONS</code> way.</p>
<p>One thing that can be difficult is debugging metaprograms (be they template or macro-based). To this end we provide a make target <code>DebugPreprocessor</code> which prints the output of running the preprocessor on the file <a class="el" href="DebugPreprocessor_8cpp.html">src/Executables/DebugPreprocessor/DebugPreprocessor.cpp</a> . Note that the output of the <code>GENERATE_INSTANTIATIONS</code> macro will be on a single line, so it often proves useful to copy-paste the output into an editor and run clang-format over the code so it's easier to reason about. </p>

<p class="reference">Referenced by <a class="el" href="classScalarWave_1_1Solutions_1_1PlaneWave.html#a0b6409925a733ea4cb629c4aec0d21af">ScalarWave::Solutions::PlaneWave&lt; Dim &gt;::d2psi_dxdx()</a>, and <a class="el" href="classEinsteinSolutions_1_1Minkowski.html#aad5576119ee938b85834e5a2e75ebf69">EinsteinSolutions::Minkowski&lt; Dim &gt;::extrinsic_curvature()</a>.</p>

</div>
</div>
<a id="gaffde14445f49f65ff4f5b592e44ee71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffde14445f49f65ff4f5b592e44ee71a">&#9670;&nbsp;</a></span>LIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The if statement is expected to evaluate true most of the time </p>

<p class="reference">Referenced by <a class="el" href="classCoordinateMap.html#a7d5854d873345464e9af44b74f0eaebf">CoordinateMap&lt; SourceFrame, TargetFrame, Maps &gt;::inv_jacobian_impl()</a>, and <a class="el" href="classCoordinateMap.html#a391c374cc28fab2facf98ddc22895803">CoordinateMap&lt; SourceFrame, TargetFrame, Maps &gt;::jacobian_impl()</a>.</p>

</div>
</div>
<a id="ga9d571cd642604cb7bd87bb039ca3760f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d571cd642604cb7bd87bb039ca3760f">&#9670;&nbsp;</a></span>SPECTRE_ALWAYS_INLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPECTRE_ALWAYS_INLINE&#160;&#160;&#160;inline</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always inline a function. Only use this if you benchmarked the code. </p>

<p class="reference">Referenced by <a class="el" href="structTensorExpressions_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsLie50499b100ea0125a8cc24bbdb8a6f38.html#a6fe75e4248ca25ffc77cbb0decca4643">TensorExpressions::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::AddSub()</a>, <a class="el" href="structMakeWithValueImpls_1_1MakeWithValueImpl.html#ad60ba3c9d09de31dba605d06d46e956b">MakeWithValueImpls::MakeWithValueImpl&lt; R, T &gt;::apply()</a>, <a class="el" href="classCoordinateMap.html#a44481bbaa5fe5f8f86587d861e3760c7">CoordinateMap&lt; SourceFrame, TargetFrame, Maps &gt;::call_impl()</a>, <a class="el" href="group__TensorExpressions.html#ga67ef93312c7f2e65f6fae4cf04477aed">TensorExpressions::contract()</a>, <a class="el" href="classCoordinateMap.html#a4ab04d4f1d0d2e57252ae3bda349b6f3">CoordinateMap&lt; SourceFrame, TargetFrame, Maps &gt;::CoordinateMap()</a>, <a class="el" href="group__ConstantExpressions.html#ga7e56b6f693d86c6a5d304db2db4c0d00">cube()</a>, <a class="el" href="structTensorExpressions_1_1TensorContract.html#add0318a11fbb05b9ca4d41d62f1a40d9">TensorExpressions::TensorContract&lt; Index1, Index2, T, X, Symm, IndexList, ArgsList &gt;::fill_contracting_tensor_index()</a>, <a class="el" href="structTensorExpressions_1_1AddSub_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsLie50499b100ea0125a8cc24bbdb8a6f38.html#ae9f5135e221ee4ee686aba22658cba9f">TensorExpressions::AddSub&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt;, Sign &gt;::get()</a>, <a class="el" href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01IndexList_00_01ArgsList_3_01Args_8_8_8_01_4_01_4.html#a26264b17dadb7a457337731076c49202">TensorExpression&lt; Derived, DataType, Symm, IndexList, ArgsList&lt; Args... &gt; &gt;::get()</a>, <a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#aeacd9cf2e8d612c4cd3601d7df5e2cec">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;::get_tensor_index()</a>, <a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#a54e1c3ac3b180648f030221b97b4bb30">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;::index_dim()</a>, <a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#a466903df83d7e1230f1aa921bb2c112a">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;::index_dims()</a>, <a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#a98f40605f3a0625b9f8fa74118e7a979">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;::index_types()</a>, <a class="el" href="classCoordinateMap.html#ad240fd1e719ecb676f513083a4f45065">CoordinateMap&lt; SourceFrame, TargetFrame, Maps &gt;::inverse_impl()</a>, <a class="el" href="MakeArray_8hpp.html#a7e2cb2f499bb63bdbee230a444b874b6">make_array()</a>, <a class="el" href="classVariables_3_01tmpl_1_1list_3_01Tags_8_8_8_01_4_01_4.html#a5136d2a917b95cfb92ed10c74e851ab0">Variables&lt; tmpl::list&lt; Tags... &gt; &gt;::operator/()</a>, <a class="el" href="structTensorExpression_3_01Derived_00_01DataType_00_01Symm_00_01IndexList_00_01ArgsList_3_01Args_8_8_8_01_4_01_4.html#a021456b859e583c9f696911e00b2350a">TensorExpression&lt; Derived, DataType, Symm, IndexList, ArgsList&lt; Args... &gt; &gt;::operator~()</a>, <a class="el" href="structTensorExpressions_1_1Product_3_01T1_00_01T2_00_01ArgsList1_3_01Args1_8_8_8_01_4_00_01ArgsList2_3_01Args2_8_8_8_01_4_01_4.html#a67725bfe70a897f3293da71f9536dfaf">TensorExpressions::Product&lt; T1, T2, ArgsList1&lt; Args1... &gt;, ArgsList2&lt; Args2... &gt; &gt;::Product()</a>, <a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#aaea80e716b200eee1a0d2501a47a6a72">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;::rank()</a>, and <a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#a6cf60b331c4229d3b42319d86d5f726a">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;::symmetries()</a>.</p>

</div>
</div>
<a id="gaaf62c1282f8b71500bbe2f4a4e945b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf62c1282f8b71500bbe2f4a4e945b66">&#9670;&nbsp;</a></span>SPECTRE_JUST_ALWAYS_INLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPECTRE_JUST_ALWAYS_INLINE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always inline a function, but do not mark it <code>inline</code> </p>

<p class="reference">Referenced by <a class="el" href="classAlgorithmImpl_3_01ParallelComponent_00_01ChareType_00_01Metavariables_00_01tmpl_1_1list_3_05216f3256a498cdc6e28f87f21b55216.html#a8b6246a999712921ce06122117b772a3">AlgorithmImpl&lt; ParallelComponent, ChareType, Metavariables, tmpl::list&lt; ActionsPack... &gt;, tmpl::list&lt; InboxTagsPack... &gt;, ArrayIndex, InitialDataBox &gt;::get_terminate()</a>.</p>

</div>
</div>
<a id="gab10d0a221f4d7a706701b806c8135fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10d0a221f4d7a706701b806c8135fd7">&#9670;&nbsp;</a></span>UNLIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNLIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The if statement is expected to evaluate false most of the time </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga01ee1794935080949a6995ae7d5e08cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01ee1794935080949a6995ae7d5e08cc">&#9670;&nbsp;</a></span>flat_all</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Utilities.html#ga01ee1794935080949a6995ae7d5e08cc">tmpl2::flat_all</a> = typedef <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt;<a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, Bs...&gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, (static_cast&lt;void&gt;(Bs), true)...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical AND between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="el" href="structcpp17_1_1conjunction.html" title="A logical AND on the template parameters. ">cpp17::conjunction</a> and <a class="el" href="structcpp17_1_1disjunction.html" title="A logical OR on the template parameters. ">cpp17::disjunction</a> use recursion </p>

</div>
</div>
<a id="ga6e25dbfa539ff4513329969dbcd81c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e25dbfa539ff4513329969dbcd81c40">&#9670;&nbsp;</a></span>flat_any</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Utilities.html#ga6e25dbfa539ff4513329969dbcd81c40">tmpl2::flat_any</a> = typedef <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; bool, not <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, Bs...&gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, (static_cast&lt;void&gt;(Bs), false)...&gt; &gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical OR between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="el" href="structcpp17_1_1conjunction.html" title="A logical AND on the template parameters. ">cpp17::conjunction</a> and <a class="el" href="structcpp17_1_1disjunction.html" title="A logical OR on the template parameters. ">cpp17::disjunction</a> use recursion </p>

</div>
</div>
<a id="gaf20b9d9f0e5870cc74c49bdf971e2cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf20b9d9f0e5870cc74c49bdf971e2cc6">&#9670;&nbsp;</a></span>make_boost_variant_over</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Utilities.html#gaf20b9d9f0e5870cc74c49bdf971e2cc6">make_boost_variant_over</a> =  typename detail::make_boost_variant_over_impl&lt;Sequence&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a boost::variant with all all the types inside the typelist Sequence. </p>
<p><em>Returns:</em> boost::variant of all types inside <code>Sequence</code> </p>

</div>
</div>
<a id="ga084d535585c18d4e80f8ec6052d341a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084d535585c18d4e80f8ec6052d341a3">&#9670;&nbsp;</a></span>Requires</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Utilities.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a> =  typename Requires_detail::requires_impl&lt; B&gt;::template_error_type_failed_to_meet_requirements_on_template_parameters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Express requirements on the template parameters of a function or class, replaces <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> </p>
<p>Replacement for <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> and Concepts for expressing requirements on template parameters. This does not require merging of the Concepts TS (whose merit is debatable) and provides an "error message" if substitution of a template parameter failed. Specifically, the compiler error will contain "template_error_type_failed_to_meet_requirements_on_template_parameters", aiding the user of a function or class in tracking down the list of requirements on the deduced type.</p>
<p>For example, if a function <code>foo</code> is defined as: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::vector, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div><div class="line"><a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;vector&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p>then calling the function with a list, <code>foo(<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt;double&gt;{});</code> results in the following compilation error from clang: </p><div class="fragment"><div class="line">./tests/Unit/Utilities/Test_Requires.cpp:29:3: error: no matching <span class="keyword">function</span></div><div class="line">   <span class="keywordflow">for</span> call to <span class="stringliteral">&#39;foo&#39;</span></div><div class="line">  foo(<a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/list.html">std::list&lt;double&gt;</a>{});</div><div class="line">  ^~~</div><div class="line">./tests/Unit/Utilities/Test_Requires.cpp:15:13: note: candidate</div><div class="line">    <span class="keyword">template</span> ignored: substitution failure [with T = std::__1::list&lt;double,</div><div class="line">    std::__1::allocator&lt;double&gt; &gt;]: no <a class="code" href="namespaceParallel.html#aa818bfd01f755b6e721a2c1f0aa075bf">type</a> named</div><div class="line">    <span class="stringliteral">&#39;template_error_type_failed_to_meet_requirements_on_template_parameters&#39;</span></div><div class="line">    in <span class="stringliteral">&#39;Requires_detail::requires_impl&lt;false&gt;&#39;</span></div><div class="line"><a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp;) {</div><div class="line">            ^</div><div class="line">1 error generated.</div></div><!-- fragment --><p>Here is an example of how write function overloads using <code>Requires</code> or to express constraints on the template parameters: </p><div class="fragment"><div class="line"><span class="comment">/// [foo_definition]</span></div><div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::vector, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div><div class="line"><a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;vector&quot;</span>;</div><div class="line">}<span class="comment"></span></div><div class="line"><span class="comment">/// [foo_definition]</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::list, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div><div class="line"><a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;list&quot;</span>;</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Using <code>Requires</code> is safer than using <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> because the nested type alias is of type <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/nullptr_t.html">std::nullptr_t</a></code> and so usage is always: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;(<span class="keywordtype">bool</span> depending on T)&gt; = <span class="keywordtype">nullptr</span>&gt;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga9d33140d1e46af90392a957855ea2a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d33140d1e46af90392a957855ea2a83">&#9670;&nbsp;</a></span>TaggedTupleTypelist</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Utilities.html#ga9d33140d1e46af90392a957855ea2a83">tuples::TaggedTupleTypelist</a> = typedef typename TaggedTuple_detail::tagged_tuple_typelist_impl&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4dabf6319ff36d72095831fba701afc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dabf6319ff36d72095831fba701afc1">&#9670;&nbsp;</a></span>typelist</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Utilities.html#ga4dabf6319ff36d72095831fba701afc1">typelist</a> =  tmpl::list&lt;Ts...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a typelist of types <code>Ts</code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadcdd6af307bde8b3bf0650395c9768a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcdd6af307bde8b3bf0650395c9768a7">&#9670;&nbsp;</a></span>all_but_specified_element_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ElementToRemove, typename T , size_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Dim - 1&gt; all_but_specified_element_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an array from an existing array omitting one element. </p>

<p class="reference">References <a class="el" href="group__Utilities.html#ga818f101f2f8bd824a3bc7c2c2361c560">gsl::at()</a>.</p>

</div>
</div>
<a id="ga818f101f2f8bd824a3bc7c2c2361c560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga818f101f2f8bd824a3bc7c2c2361c560">&#9670;&nbsp;</a></span>at() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N, typename Size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; gsl::at </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid. </p>

<p class="reference">References <a class="el" href="group__ErrorHandling.html#ga128eed9cc242b5e850cf1391744bf099">Expects</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__Utilities.html#gadcdd6af307bde8b3bf0650395c9768a7">all_but_specified_element_of()</a>, <a class="el" href="structActions_1_1SendDataForFluxes.html#a9bc61a6da791a1c32e12349654aa210c">Actions::SendDataForFluxes&lt; Receiver &gt;::apply()</a>, <a class="el" href="group__ComputationalDomain.html#ga1184e9f52cfd40ae865bf8bdd13d5e54">create_initial_element()</a>, <a class="el" href="classScalarWave_1_1Solutions_1_1PlaneWave.html#a07593e6355b2e0676769e881ca39731a">ScalarWave::Solutions::PlaneWave&lt; Dim &gt;::d2psi_dtdx()</a>, <a class="el" href="classScalarWave_1_1Solutions_1_1PlaneWave.html#a0b6409925a733ea4cb629c4aec0d21af">ScalarWave::Solutions::PlaneWave&lt; Dim &gt;::d2psi_dxdx()</a>, <a class="el" href="classScalarWave_1_1Solutions_1_1PlaneWave.html#a3a3c053b6dc02c22de8d819ff779490a">ScalarWave::Solutions::PlaneWave&lt; Dim &gt;::dpsi_dx()</a>, <a class="el" href="classElementIndex.html#a8e5962a00d6846b98dbe01beafabed8d">ElementIndex&lt; VolumeDim &gt;::ElementIndex()</a>, <a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#ace4690cfacfb096fbc8e6b6d6117fc1b">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;::get()</a>, <a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#aa264988a357e300dd3b1f9b6f8e98104">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;::get_vector_of_data()</a>, <a class="el" href="classElementId.html#a8dbc15dfc4bb3060e76c2215ad73d8a6">ElementId&lt; VolumeDim &gt;::id_of_child()</a>, <a class="el" href="classElementId.html#a89fb2c413dd83c54350fc9d81167f1f1">ElementId&lt; VolumeDim &gt;::id_of_parent()</a>, <a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#aa4a100ce633b686c0a07b9f558644fe4">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;::index_dim()</a>, <a class="el" href="group__ComputationalDomain.html#ga75b3b09631eb57f4317f5c12fd7cf694">interface_logical_coordinates()</a>, <a class="el" href="group__NumericalAlgorithms.html#ga96db32cc92f91bb27dccadb87f16d247">linearize()</a>, <a class="el" href="ConstantExpressions_8hpp.html#a9c63793d5a8986fb6f9013033c4a2991">make_array_from_list()</a>, <a class="el" href="classOrientation.html#a4a73f1d951370e844c09a5992f246e3b">Orientation&lt; VolumeDim &gt;::mapped()</a>, <a class="el" href="StdHelpers_8hpp.html#a858ae12e853908b50a3605a4ff4e2065">operator*()</a>, <a class="el" href="DataVector_8hpp.html#abe27244d4a3343424869b8e7986f12ba">operator+()</a>, <a class="el" href="classGeneralIndexIterator.html#a915979b14d3f8cdc7f76e777d71af5f4">GeneralIndexIterator&lt; Container &gt;::operator++()</a>, <a class="el" href="DataVector_8hpp.html#a66636726420e4d50b0d6eb6c05992693">operator+=()</a>, <a class="el" href="DataVector_8hpp.html#a60f7a135fa16ac0440c35ff178a1b92e">operator-()</a>, <a class="el" href="DataVector_8hpp.html#a937f0371abe78051588b0aeb43aed230">operator-=()</a>, <a class="el" href="StdHelpers_8hpp.html#a194de1c0f92150bbb88555a4c323f2cd">operator/()</a>, <a class="el" href="classIndex.html#ae94c13676006986b619b2d543bd8ea06">Index&lt; Dim &gt;::operator[]()</a>, <a class="el" href="classTensor_3_01X_00_01Symm_00_01IndexList_3_01Indices_8_8_8_01_4_01_4.html#a78c4b734964658b77f827ba56e7b82b5">Tensor&lt; X, Symm, IndexList&lt; Indices... &gt; &gt;::operator[]()</a>, <a class="el" href="classOrientation.html#a274192918a73b9d2e1d20f7fe59df81c">Orientation&lt; VolumeDim &gt;::Orientation()</a>, <a class="el" href="group__NumericalAlgorithms.html#ga5470f2a8248d6998c9295e4baa90022e">partial_derivatives()</a>, <a class="el" href="classYlmSpherepack.html#a677c72afbc9546d68db50cb3796b0f6f">YlmSpherepack::second_derivative()</a>, and <a class="el" href="classIndex.html#a9b6ad7896736a317a819da3d576802b6">Index&lt; Dim &gt;::slice_away()</a>.</p>

</div>
</div>
<a id="ga1648d283e2a226cd398dbea1de84e88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1648d283e2a226cd398dbea1de84e88d">&#9670;&nbsp;</a></span>at() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cont , typename Size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const Cont::value_type&amp; gsl::at </td>
          <td>(</td>
          <td class="paramtype">const Cont &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid. </p>

<p class="reference">References <a class="el" href="group__ErrorHandling.html#ga128eed9cc242b5e850cf1391744bf099">Expects</a>.</p>

</div>
</div>
<a id="gac75622e2034e12763b1e3989b813376b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac75622e2034e12763b1e3989b813376b">&#9670;&nbsp;</a></span>at() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T&amp; gsl::at </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid. </p>

<p class="reference">References <a class="el" href="group__ErrorHandling.html#ga128eed9cc242b5e850cf1391744bf099">Expects</a>.</p>

</div>
</div>
<a id="gaa9e9df95875a2fa4b6ec2acfe7fa26ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9e9df95875a2fa4b6ec2acfe7fa26ff">&#9670;&nbsp;</a></span>current_date_and_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> current_date_and_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current date and time. </p>

<p class="reference">References <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/chrono/system_clock/now.html">std::chrono::system_clock::now()</a>, and <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/chrono/system_clock/to_time_t.html">std::chrono::system_clock::to_time_t()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classInformer.html#a43fced4a7f0c6a6b2db19869791bf60b">Informer::print_exit_info()</a>, and <a class="el" href="classInformer.html#a8cc4c48811fe91eb783f490044f2ef2b">Informer::print_startup_info()</a>.</p>

</div>
</div>
<a id="gaaa46a305d87ee4ae9fede9d55c373286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa46a305d87ee4ae9fede9d55c373286">&#9670;&nbsp;</a></span>ddot_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ddot_ </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dot product of two vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>the length of the vectors. </td></tr>
    <tr><td class="paramname">X</td><td>a pointer to the first element of the first vector. </td></tr>
    <tr><td class="paramname">INCX</td><td>the stride for the elements of the first vector. </td></tr>
    <tr><td class="paramname">Y</td><td>a pointer to the first element of the second vector. </td></tr>
    <tr><td class="paramname">INCY</td><td>the stride for the elements of the second vector. </td></tr>
  </table>
  </dd>
</dl>
<p><em>Returns:</em> the dot product of the given vectors. </p>

<p class="reference">Referenced by <a class="el" href="classYlmSpherepack.html#a7b4c3a1af5c148c9c155e239863a126f">YlmSpherepack::definite_integral()</a>, and <a class="el" href="namespaceBasis_1_1lgl.html#a041a067f9ef65a74302298d114c23aec">Basis::lgl::definite_integral&lt; 1 &gt;()</a>.</p>

</div>
</div>
<a id="gaccb7d5132ccd60f32c504c51f9d7fb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccb7d5132ccd60f32c504c51f9d7fb3c">&#9670;&nbsp;</a></span>dereference_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) dereference_wrapper </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reference object held by a reference wrapper, if a non-reference_wrapper type is passed in then the object is returned. </p>

<p class="reference">Referenced by <a class="el" href="classCoordinateMaps_1_1Identity.html#a9be48b4f0017aaa55dbe55654c38b791">CoordinateMaps::Identity&lt; Dim &gt;::inv_jacobian()</a>, <a class="el" href="classCoordinateMaps_1_1AffineMap.html#a9e02a70352def10084871758359dca1e">CoordinateMaps::AffineMap::inv_jacobian()</a>, <a class="el" href="classCoordinateMaps_1_1Rotation_3_012_01_4.html#a4e62167a4ae5fa03ad28fff99cf45d89">CoordinateMaps::Rotation&lt; 2 &gt;::inv_jacobian()</a>, <a class="el" href="classCoordinateMaps_1_1Rotation_3_013_01_4.html#a99e213f5d29c4400a4bbc7266f75c151">CoordinateMaps::Rotation&lt; 3 &gt;::inv_jacobian()</a>, <a class="el" href="classCoordinateMaps_1_1ProductOf3Maps.html#ac5b39e79884c7938083ecff7a1c6375e">CoordinateMaps::ProductOf3Maps&lt; Map1, Map2, Map3 &gt;::inv_jacobian()</a>, <a class="el" href="classCoordinateMaps_1_1Identity.html#abf6e3fa9eb82b654760a1ff7808f2b96">CoordinateMaps::Identity&lt; Dim &gt;::jacobian()</a>, <a class="el" href="classCoordinateMaps_1_1AffineMap.html#aad01dac18489a930addf85dc3dcf698b">CoordinateMaps::AffineMap::jacobian()</a>, <a class="el" href="classCoordinateMaps_1_1Rotation_3_012_01_4.html#ace73987dfade6f5561aa474f9ac78343">CoordinateMaps::Rotation&lt; 2 &gt;::jacobian()</a>, <a class="el" href="classCoordinateMaps_1_1Rotation_3_013_01_4.html#a8e4be6de73a158e72c6f523827f5b6d2">CoordinateMaps::Rotation&lt; 3 &gt;::jacobian()</a>, and <a class="el" href="classCoordinateMaps_1_1ProductOf3Maps.html#adcd87f020ca896045ecaa547dfb28edd">CoordinateMaps::ProductOf3Maps&lt; Map1, Map2, Map3 &gt;::jacobian()</a>.</p>

</div>
</div>
<a id="gac932a44b57087d32ce5341314437dbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac932a44b57087d32ce5341314437dbbd">&#9670;&nbsp;</a></span>dgemm_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseLibXsmm = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dgemm_ </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a matrix-matrix multiplication. </p>
<p>Perform the matrix-matrix multiplication </p><p class="formulaDsp">
\[ C = \alpha \mathrm{op}(A) \mathrm{op}(B) + \beta \mathrm{op}(C) \]
</p>
<p>where \(\mathrm{op}(A)\) represents either \(A\) or \(A^{T}\) (transpose of \(A\)).</p>
<p>LIBXSMM, which is much faster than BLAS for small matrices, can be called instead of BLAS by passing the template parameter <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TRANSA</td><td>either 'N', 'T' or 'C', transposition of matrix A </td></tr>
    <tr><td class="paramname">TRANSB</td><td>either 'N', 'T' or 'C', transposition of matrix B </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns in \(\mathrm{op}(B)\) and \(\mathrm{op}(C)\) </td></tr>
    <tr><td class="paramname">K</td><td>Number of columns in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">ALPHA</td><td>specifies \(\alpha\) </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix. ">Matrix</a> \(A\) </td></tr>
    <tr><td class="paramname">LDA</td><td>Specifies first dimension of \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix. ">Matrix</a> \(B\) </td></tr>
    <tr><td class="paramname">LDB</td><td>Specifies first dimension of \(\mathrm{op}(B)\) </td></tr>
    <tr><td class="paramname">BETA</td><td>specifies \(\beta\) </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix. ">Matrix</a> \(C\) </td></tr>
    <tr><td class="paramname">LDC</td><td>Specifies first dimension of \(\mathrm{op}(C)\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UseLibXsmm</td><td>if <code>true</code> then use LIBXSMM </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__ErrorHandling.html#gaf170f3984e3d0f809b2558dbd981ca35">ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceBasis_1_1lgl.html#acd680a8f9d7a2d2dde59e20df2ebe4fa">Basis::lgl::linear_filter_matrix()</a>, and <a class="el" href="group__NumericalAlgorithms.html#ga5470f2a8248d6998c9295e4baa90022e">partial_derivatives()</a>.</p>

</div>
</div>
<a id="gaba62a62589ffc7b8b85a7722390f7ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba62a62589ffc7b8b85a7722390f7ce0">&#9670;&nbsp;</a></span>dgemm_< true >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Utilities.html#gac932a44b57087d32ce5341314437dbbd">dgemm_</a>&lt; true &gt; </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a matrix-matrix multiplication. </p>
<p>Perform the matrix-matrix multiplication </p><p class="formulaDsp">
\[ C = \alpha \mathrm{op}(A) \mathrm{op}(B) + \beta \mathrm{op}(C) \]
</p>
<p>where \(\mathrm{op}(A)\) represents either \(A\) or \(A^{T}\) (transpose of \(A\)).</p>
<p>LIBXSMM, which is much faster than BLAS for small matrices, can be called instead of BLAS by passing the template parameter <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TRANSA</td><td>either 'N', 'T' or 'C', transposition of matrix A </td></tr>
    <tr><td class="paramname">TRANSB</td><td>either 'N', 'T' or 'C', transposition of matrix B </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns in \(\mathrm{op}(B)\) and \(\mathrm{op}(C)\) </td></tr>
    <tr><td class="paramname">K</td><td>Number of columns in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">ALPHA</td><td>specifies \(\alpha\) </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix. ">Matrix</a> \(A\) </td></tr>
    <tr><td class="paramname">LDA</td><td>Specifies first dimension of \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix. ">Matrix</a> \(B\) </td></tr>
    <tr><td class="paramname">LDB</td><td>Specifies first dimension of \(\mathrm{op}(B)\) </td></tr>
    <tr><td class="paramname">BETA</td><td>specifies \(\beta\) </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix. ">Matrix</a> \(C\) </td></tr>
    <tr><td class="paramname">LDC</td><td>Specifies first dimension of \(\mathrm{op}(C)\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UseLibXsmm</td><td>if <code>true</code> then use LIBXSMM </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__ErrorHandling.html#gaf170f3984e3d0f809b2558dbd981ca35">ASSERT</a>, and <a class="el" href="group__Utilities.html#ga2da8b404f35c108209c4ce27c8d50e1c">gsl::narrow_cast()</a>.</p>

</div>
</div>
<a id="gad4d31316e0975f0a66a60d9ac92756a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4d31316e0975f0a66a60d9ac92756a8">&#9670;&nbsp;</a></span>dgemv_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dgemv_ </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a matrix-vector multiplication. </p>
<p class="formulaDsp">
\[ y = \alpha \mathrm{op}(A) x + \beta y \]
</p>
<p>where \(\mathrm{op}(A)\) represents either \(A\) or \(A^{T}\) (transpose of \(A\)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TRANS</td><td>either 'N', 'T' or 'C', transposition of matrix A </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">ALPHA</td><td>specifies \(\alpha\) </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix. ">Matrix</a> \(A\) </td></tr>
    <tr><td class="paramname">LDA</td><td>Specifies first dimension of \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">X</td><td>Vector \(x\) </td></tr>
    <tr><td class="paramname">INCX</td><td>Specifies the increment for the elements of \(x\) </td></tr>
    <tr><td class="paramname">BETA</td><td>Specifies \(\beta\) </td></tr>
    <tr><td class="paramname">Y</td><td>Vector \(y\) </td></tr>
    <tr><td class="paramname">INCY</td><td>Specifies the increment for the elements of \(y\) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__ErrorHandling.html#gaf170f3984e3d0f809b2558dbd981ca35">ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__NumericalAlgorithms.html#ga96db32cc92f91bb27dccadb87f16d247">linearize()</a>.</p>

</div>
</div>
<a id="ga9a7c7ee897f581360154a3676d5f7ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7c7ee897f581360154a3676d5f7ab9">&#9670;&nbsp;</a></span>formatted_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> formatted_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a string like printf. </p>
<p>Given a formatting string and arguments this returns the corresponding string. Similar to printf but using std::strings. </p>

</div>
</div>
<a id="gaf29c2fe540b02e47a11c1ff9287bf169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf29c2fe540b02e47a11c1ff9287bf169">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tag , class... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const Tag::type &amp; tuples::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>. </p>

<p class="reference">References <a class="el" href="namespaceParallel.html#abe10bb124676f152e29c58c007b3b735">Parallel::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__Parallel.html#gadfb449233b977a5a9a4e218f148a2079">Parallel::get_parallel_component()</a>, and <a class="el" href="classParallel_1_1Main.html#ad31bce8155c9f055625469506748204f">Parallel::Main&lt; Metavariables &gt;::Main()</a>.</p>

</div>
</div>
<a id="gaa0295bce7da8fd1957eecb2e0f31566a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0295bce7da8fd1957eecb2e0f31566a">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tag , class... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Tag::type &amp; tuples::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>. </p>

<p class="reference">References <a class="el" href="namespaceParallel.html#abe10bb124676f152e29c58c007b3b735">Parallel::value</a>.</p>

</div>
</div>
<a id="ga3b1f97e933f2b274b8b7f2d4e92ec32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b1f97e933f2b274b8b7f2d4e92ec32e">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tag , class... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const Tag::type &amp;&amp; tuples::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>. </p>

<p class="reference">References <a class="el" href="namespaceParallel.html#abe10bb124676f152e29c58c007b3b735">Parallel::value</a>.</p>

</div>
</div>
<a id="ga30114b7db6af87e7e06e3ea6bac687eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30114b7db6af87e7e06e3ea6bac687eb">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tag , class... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Tag::type &amp;&amp; tuples::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>. </p>

<p class="reference">References <a class="el" href="group__DataBoxGroup.html#ga18ab344b7599c78f3866fd2d2bb4687c">db::apply()</a>, <a class="el" href="TaggedTuple_8hpp.html#a271a53048001dca19274bb6c6cba79e4">TUPLES_LIB_CONSTEXPR_CXX_14</a>, and <a class="el" href="namespaceParallel.html#abe10bb124676f152e29c58c007b3b735">Parallel::value</a>.</p>

</div>
</div>
<a id="gada33ac747e1720e8d6c7d89323663c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada33ac747e1720e8d6c7d89323663c3e">&#9670;&nbsp;</a></span>info_from_build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> info_from_build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information about the version, date, host, git commit, and link time. </p>
<p>The information returned by this function is invaluable for identifying the version of the code used in a simulation, as well as which host, the date the code was compiled, and the time of linkage. </p>

<p class="reference">References <a class="el" href="group__Utilities.html#ga440a175ca29c1e92a7147f210a860932">spectre_version()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classInformer.html#a8cc4c48811fe91eb783f490044f2ef2b">Informer::print_startup_info()</a>.</p>

</div>
</div>
<a id="ga495b431a620b10beb24f1afc90b77e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga495b431a620b10beb24f1afc90b77e20">&#9670;&nbsp;</a></span>keys_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename H &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> keys_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; K, V, H &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a string containing the keys of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>. </p>

</div>
</div>
<a id="gaf707b57628e9425c91d92eb278a52c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf707b57628e9425c91d92eb278a52c99">&#9670;&nbsp;</a></span>keys_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> keys_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a string containing the keys of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>. </p>

</div>
</div>
<a id="ga0ce4f7246dc4ad64d76817b8a988c056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ce4f7246dc4ad64d76817b8a988c056">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p>If T is a container the magnitude is computed separately for each element of the container.</p>
<p><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), sqrt(), and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="ga2d02f46cab8bbf00abc56508746cafde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d02f46cab8bbf00abc56508746cafde">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p>If T is a container the magnitude is computed separately for each element of the container.</p>
<p><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), sqrt(), and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="gacd04562712892d6d8f77ff26e9646a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd04562712892d6d8f77ff26e9646a19">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p>If T is a container the magnitude is computed separately for each element of the container.</p>
<p><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), sqrt(), and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="gae942ed628d83d2f9dbf39a06f2996395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae942ed628d83d2f9dbf39a06f2996395">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p>If T is a container the magnitude is computed separately for each element of the container.</p>
<p><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), sqrt(), and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="gadf6dc63579cfb3cb3a49db1945ec0fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf6dc63579cfb3cb3a49db1945ec0fe6">&#9670;&nbsp;</a></span>make_array() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t size, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;T&gt;, size&gt; make_array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper class to initialize a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">size</td><td>the length of the array </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="MakeArray_8hpp.html#a7e2cb2f499bb63bdbee230a444b874b6">make_array()</a>, <a class="el" href="group__Utilities.html#ga9d571cd642604cb7bd87bb039ca3760f">SPECTRE_ALWAYS_INLINE</a>, and <a class="el" href="namespaceParallel.html#abe10bb124676f152e29c58c007b3b735">Parallel::value</a>.</p>

</div>
</div>
<a id="ga18f579d55a04631539629be19103dcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f579d55a04631539629be19103dcae">&#9670;&nbsp;</a></span>make_array() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... V, Requires&lt;(sizeof...(V) &gt; 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;typename <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;T&gt;, sizeof...(V) + 1&gt; make_array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;...&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to initialize a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a> with varying number of arguments. </p>

<p class="reference">References <a class="el" href="group__Utilities.html#gab78389fadf763e3693ce893fad5d7fba">tmpl2::flat_all_v</a>, and <a class="el" href="group__TypeTraits.html#ga173105b805ff5fa637edb005f704feca">cpp17::is_same_v</a>.</p>

</div>
</div>
<a id="gaea51ad2c5ef8f8f99279545e1389d056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea51ad2c5ef8f8f99279545e1389d056">&#9670;&nbsp;</a></span>make_array() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t size, typename Seq &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, size&gt; make_array </td>
          <td>(</td>
          <td class="paramtype">Seq &amp;&amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, size&gt;</code> from the first <code>size</code> values of <code>seq</code> </p>
<p><em>Requires:</em> <code>Seq</code> has a <code>begin</code> function </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type held by the array </td></tr>
    <tr><td class="paramname">size</td><td>the size of the created array </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__ErrorHandling.html#ga43ee0d6e9c0381c6140d8b87d927c726">CASSERT</a>.</p>

</div>
</div>
<a id="gaa979e736ddfc838ddcba025a40a11469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa979e736ddfc838ddcba025a40a11469">&#9670;&nbsp;</a></span>make_deferred()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fp , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDeferred.html">Deferred</a>&lt;Rt1&gt; make_deferred </td>
          <td>(</td>
          <td class="paramtype">Fp&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a deferred function call object. </p>
<p>If creating a <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> with a function object the call operator of the function object must be marked <code>const</code> currently. Since the function object will only be evaluated once there currently seems to be no reason to allow mutating call operators.</p>
<h3>Example</h3>
<p>The examples below use the following functions: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>func {</div><div class="line">  <span class="keywordtype">double</span> operator()()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 8.2; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> dummy() { <span class="keywordflow">return</span> 6.7; }</div><div class="line"></div><div class="line"><span class="keyword">struct </span>func2 {</div><div class="line">  <span class="keywordtype">double</span> operator()(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; t)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> t; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> lazy_function(<span class="keyword">const</span> <span class="keywordtype">double</span> t) { <span class="keywordflow">return</span> 10.0 * t; }</div></div><!-- fragment --><p>To create a <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> using a function object use: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> def = <a class="code" href="group__Utilities.html#gaa979e736ddfc838ddcba025a40a11469">make_deferred</a>(func{});</div><div class="line">  CHECK(8.2 == def.get());</div></div><!-- fragment --><p>or using a regular function: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> def2 = <a class="code" href="group__Utilities.html#gaa979e736ddfc838ddcba025a40a11469">make_deferred</a>(dummy);</div><div class="line">  CHECK(6.7 == def2.get());</div></div><!-- fragment --><p> It is also possible to pass <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> objects to a deferred function call: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> def2 = <a class="code" href="group__Utilities.html#gaa979e736ddfc838ddcba025a40a11469">make_deferred</a>(func2{}, 6.82);</div><div class="line">  <span class="keyword">auto</span> def3 = <a class="code" href="group__Utilities.html#gaa979e736ddfc838ddcba025a40a11469">make_deferred</a>(lazy_function, def2);</div><div class="line">  CHECK(68.2 == def3.get());</div><div class="line">  CHECK(6.82 == def2.get());</div></div><!-- fragment --><p>in which case the first function will be evaluated just before the second function is evaluated.</p>
<p><em>Returns:</em> <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> object that will lazily evaluate the function </p>

<p class="reference">Referenced by <a class="el" href="classDeferred.html#aefa97aa28f32c4649c1e40b6e89c0600">Deferred&lt; Rt &gt;::mutate()</a>.</p>

</div>
</div>
<a id="gad87825ee8984324e81a2ae6ab2fec6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad87825ee8984324e81a2ae6ab2fec6ed">&#9670;&nbsp;</a></span>make_overloader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Fs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Overloader_8hpp.html#a3f27d4abd722fa18956ccdcf32602a2a">OVERLOADER_CONSTEXPR</a> <a class="el" href="classOverloader.html">Overloader</a>&lt;Fs...&gt; make_overloader </td>
          <td>(</td>
          <td class="paramtype">Fs...&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <code><a class="el" href="classOverloader.html" title="Used for overloading lambdas, useful for lambda-SFINAE. ">Overloader</a>&lt;Fs...&gt;</code>, see <a class="el" href="classOverloader.html" title="Used for overloading lambdas, useful for lambda-SFINAE. ">Overloader</a> for details. </p>

<p class="reference">Referenced by <a class="el" href="Algorithm_8hpp.html#af7d5232dff97513f915e78952f7ebb70">apply_visitor_helper()</a>, <a class="el" href="structcreate__from__yaml.html#a9b8a2e9e009f7c7a8530cb4e83cbf745">create_from_yaml&lt; T &gt;::create()</a>, <a class="el" href="group__Parallel.html#ga8ab0de2c7809926d565671512f706126">Parallel::get()</a>, <a class="el" href="classAlgorithmImpl_3_01ParallelComponent_00_01ChareType_00_01Metavariables_00_01tmpl_1_1list_3_05216f3256a498cdc6e28f87f21b55216.html#a8b6246a999712921ce06122117b772a3">AlgorithmImpl&lt; ParallelComponent, ChareType, Metavariables, tmpl::list&lt; ActionsPack... &gt;, tmpl::list&lt; InboxTagsPack... &gt;, ArrayIndex, InitialDataBox &gt;::get_terminate()</a>, <a class="el" href="classParallel_1_1Main.html#ad31bce8155c9f055625469506748204f">Parallel::Main&lt; Metavariables &gt;::Main()</a>, and <a class="el" href="namespacetuples.html#a0672013bd1d2ee84e7a31466f83c46ed">tuples::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="gafaf6db75ede2a9bc2fa4b6b17b8ef128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaf6db75ede2a9bc2fa4b6b17b8ef128">&#9670;&nbsp;</a></span>narrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gsl::narrow </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A checked version of <a class="el" href="group__Utilities.html#ga2da8b404f35c108209c4ce27c8d50e1c" title="Cast u to a type T where the cast may result in narrowing. ">narrow_cast()</a> that ERRORs if the cast changed the value. </p>

<p class="reference">References <a class="el" href="group__ErrorHandling.html#ga1d27028c1827976007fe9d29ad3a2f66">ERROR</a>, <a class="el" href="group__Utilities.html#ga2da8b404f35c108209c4ce27c8d50e1c">gsl::narrow_cast()</a>, and <a class="el" href="namespaceParallel.html#abe10bb124676f152e29c58c007b3b735">Parallel::value</a>.</p>

</div>
</div>
<a id="ga2da8b404f35c108209c4ce27c8d50e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2da8b404f35c108209c4ce27c8d50e1c">&#9670;&nbsp;</a></span>narrow_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gsl::narrow_cast </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast <code>u</code> to a type <code>T</code> where the cast may result in narrowing. </p>

<p class="reference">Referenced by <a class="el" href="group__Utilities.html#gaba62a62589ffc7b8b85a7722390f7ce0">dgemm_&lt; true &gt;()</a>, and <a class="el" href="group__Utilities.html#gafaf6db75ede2a9bc2fa4b6b17b8ef128">gsl::narrow()</a>.</p>

</div>
</div>
<a id="ga1eed7cb45692393b257c3987070d1da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eed7cb45692393b257c3987070d1da2">&#9670;&nbsp;</a></span>number_of_digits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T number_of_digits </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of digits in an integer number. </p>

<p class="reference">References <a class="el" href="namespacett.html#a1199b80c0851bbf8b025c562054397ec">tt::is_integer_v</a>.</p>

</div>
</div>
<a id="ga9c127d07f412267ea6548c8dab8b44c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c127d07f412267ea6548c8dab8b44c1">&#9670;&nbsp;</a></span>operator"" _st()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t operator&quot;&quot; _st </td>
          <td>(</td>
          <td class="paramtype">const unsigned long long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the _st size_t suffix. </p>

</div>
</div>
<a id="ga49015243242c2caad5bdbd64ea7449a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49015243242c2caad5bdbd64ea7449a1">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>. </p>

</div>
</div>
<a id="ga4b8db62a17e01a839e499a4c59112df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b8db62a17e01a839e499a4c59112df5">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>. </p>

</div>
</div>
<a id="ga3acb5ffe1cdbc6f9fb1a506584f8f132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3acb5ffe1cdbc6f9fb1a506584f8f132">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>. </p>

</div>
</div>
<a id="ga85ca1c2d4ff05b9b2d683f207d58be92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85ca1c2d4ff05b9b2d683f207d58be92">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>. </p>

</div>
</div>
<a id="ga81330e34bc91cfbd33c4d5272d33c53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81330e34bc91cfbd33c4d5272d33c53b">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream operator for tuples. </p>

</div>
</div>
<a id="gadaa1563de19d53297daf7861a5170f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaa1563de19d53297daf7861a5170f2f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename H &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; K, V, H &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output all the key, value pairs of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>. </p>

</div>
</div>
<a id="gaaa8b69f709871a3517de357ffaec062e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8b69f709871a3517de357ffaec062e">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output all the key, value pairs of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>. </p>

</div>
</div>
<a id="gaf389850e8ebc7d8040dfb5a50036f0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf389850e8ebc7d8040dfb5a50036f0ee">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>. </p>

</div>
</div>
<a id="ga23e067621bfcb4fcef006fd36b1a2909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23e067621bfcb4fcef006fd36b1a2909">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt; T, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>. </p>

</div>
</div>
<a id="ga5a4affaa7af20b9ab232a5cae60d1fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a4affaa7af20b9ab232a5cae60d1fd5">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Requires&lt; tt::is_streamable&lt; std::ostream, T &gt;::value &gt; &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream operator for <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>. </p>

<p class="reference">References <a class="el" href="namespaceParallel.html#abe10bb124676f152e29c58c007b3b735">Parallel::value</a>.</p>

</div>
</div>
<a id="ga78d6a6a95d4ebc4e5fca330a272a6182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78d6a6a95d4ebc4e5fca330a272a6182">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Requires&lt; tt::is_streamable&lt; std::ostream, T &gt;::value &gt; &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream operator for <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>. </p>

</div>
</div>
<a id="gadcbd91b985044319a768092b12cd5045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcbd91b985044319a768092b12cd5045">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream operator for <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>. </p>

</div>
</div>
<a id="ga6c00908b8856ad6d441d443d22586d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c00908b8856ad6d441d443d22586d0a">&#9670;&nbsp;</a></span>simplest_fraction_in_interval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fraction , typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Fraction simplest_fraction_in_interval </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the fraction in the supplied interval with the smallest denominator. </p>
<p>The endpoints are considered to be in the interval. The order of the arguments is not significant. The answer is unique as long as the interval has length less than 1; for longer intervals, an integer in the range will be returned. </p>

<p class="reference">References <a class="el" href="classContinuedFractionSummer.html#a51aa04c2968bd5ad830e3650b4542984">ContinuedFractionSummer&lt; Fraction &gt;::insert()</a>, and <a class="el" href="classContinuedFractionSummer.html#a4025746080639fbc1551383e5e38f885">ContinuedFractionSummer&lt; Fraction &gt;::value()</a>.</p>

</div>
</div>
<a id="ga36b2bffa5f55447db8d65c1e045d626a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36b2bffa5f55447db8d65c1e045d626a">&#9670;&nbsp;</a></span>spectre_major_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spectre_major_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns major version. </p>

</div>
</div>
<a id="gaddcfc56ecb94ec0577388d27f7431bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddcfc56ecb94ec0577388d27f7431bb2">&#9670;&nbsp;</a></span>spectre_minor_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spectre_minor_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns minor version. </p>

</div>
</div>
<a id="ga9158b176bca8b48872287187b6101250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9158b176bca8b48872287187b6101250">&#9670;&nbsp;</a></span>spectre_patch_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spectre_patch_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns patch version. </p>

</div>
</div>
<a id="ga440a175ca29c1e92a7147f210a860932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga440a175ca29c1e92a7147f210a860932">&#9670;&nbsp;</a></span>spectre_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> spectre_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a string containing the current version of SpECTRE. </p>

<p class="reference">Referenced by <a class="el" href="group__Utilities.html#gada33ac747e1720e8d6c7d89323663c3e">info_from_build()</a>.</p>

</div>
</div>
<a id="ga8b6ade329d6c1dbce2c67a94a58b2304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b6ade329d6c1dbce2c67a94a58b2304">&#9670;&nbsp;</a></span>swallow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void swallow </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows zero-cost unordered expansion of a parameter. </p>
<h3>Details</h3>
<p>Expands a parameter pack, typically useful for runtime evaluation via a Callable such as a lambda, function, or function object. For example, an unordered transform of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> can be implemented as: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Elements, <span class="keywordtype">size_t</span>... Is&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">transform</a>(<span class="keyword">const</span> <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Elements...&gt;</a>&amp; tupull,</div><div class="line">               <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Elements...&gt;</a>&amp; out_tupull,</div><div class="line">               <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::index_sequence&lt;Is...&gt;</a> <span class="comment">/*meta*/</span>) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> func = [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; in, <span class="keyword">auto</span>&amp; out) {</div><div class="line">    out = in * <span class="keyword">static_cast&lt;</span>decltype(in)<span class="keyword">&gt;</span>(2);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  };</div><div class="line">  <a class="code" href="group__Utilities.html#ga8b6ade329d6c1dbce2c67a94a58b2304">swallow</a>(func(std::get&lt;Is&gt;(tupull), std::get&lt;Is&gt;(out_tupull))...);</div><div class="line">}</div><div class="line">}  <span class="comment">// namespace</span></div><div class="line"></div><div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Utilities.swallow&quot;</span>, <span class="stringliteral">&quot;[Utilities][Unit]&quot;</span>) {</div><div class="line">  <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;int, double, float&gt;</a> my_tupull = std::make_tuple(3, 2.7, 8.2);</div><div class="line">  <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;int, double, float&gt;</a> my_tupull_output;</div><div class="line">  <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">transform</a>(my_tupull, my_tupull_output, <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence&lt;3&gt;</a>{});</div><div class="line">  CHECK(std::get&lt;0&gt;(my_tupull_output) == 6);</div><div class="line">  CHECK(std::get&lt;1&gt;(my_tupull_output) == 5.4);</div><div class="line">  CHECK(std::get&lt;2&gt;(my_tupull_output) == 16.4f);</div><div class="line">}</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple. ">tuple_fold</a> <a class="el" href="group__Utilities.html#ga3f67981c777b6762ada9da5ad5da11e7" title="Perform a fold over a std::tuple. ">tuple_counted_fold</a> <a class="el" href="group__Utilities.html#gad65147320c04e61267089a58d71a6302" title="Perform a transform over a std::tuple. ">tuple_transform</a> <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classtuples_1_1TaggedTuple.html#a9676216a606a0adc610e330e1f203195">tuples::TaggedTuple&lt; InboxTagsPack... &gt;::operator=()</a>, and <a class="el" href="classtuples_1_1TaggedTuple.html#a47682bdcb4262a5d968502042f86b90a">tuples::TaggedTuple&lt; InboxTagsPack... &gt;::swap()</a>.</p>

</div>
</div>
<a id="ga3f67981c777b6762ada9da5ad5da11e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f67981c777b6762ada9da5ad5da11e7">&#9670;&nbsp;</a></span>tuple_counted_fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void tuple_counted_fold </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_aryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a fold over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. </p>
<h3>Details</h3>
<p>Iterates over the elements in a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <code>tuple</code> from left to right (left fold) calling <code>op(element, args...)</code> on each element in <code>tuple</code>. A right fold can be done by explicitly setting the first template parameter to true. Folds are easily implemented using <code>tuple_fold</code> by updating one of the <code>args...</code> at each iteration. If you need the index of the current element you can use the <code>tuple_counted_fold</code> variant. <code>tuple_counted_fold</code> passes the current index as the second argument to the Callable <code>op</code>. That is, <code>op(element, index, args...)</code>.</p>
<h3>Example</h3>
<p>The sum of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> of Arithmetics can be computed in several ways. First, you can use a lambda: </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div><div class="line">    <span class="keywordtype">double</span> sum_value = 0.0;</div><div class="line">    <a class="code" href="group__Utilities.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a>(my_tupull,</div><div class="line">               [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element, <span class="keywordtype">double</span>&amp; state) { state += element; },</div><div class="line">               sum_value);</div><div class="line">    CHECK(sum_value == approx(26.1));</div></div><!-- fragment --><p>You'll notice that <code>state</code> is taken by reference and mutated.</p>
<p>You can do the same thing with a struct defined as </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>tuple_fold_plus {</div><div class="line">  T <a class="code" href="namespaceParallel.html#abe10bb124676f152e29c58c007b3b735">value</a> = 0.0;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;</div><div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> S&amp; element) {</div><div class="line">    value += element;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>and then using an instance of the struct </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div><div class="line">    tuple_fold_plus&lt;double&gt; sum_value{};</div><div class="line">    <a class="code" href="group__Utilities.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a>(my_tupull, sum_value);</div><div class="line">    CHECK(sum_value.value == approx(26.1));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You are not able to pass a function pointer to <code>tuple_fold</code> or <code>tuple_counted_fold</code> because you cannot pass a pointer to a function template, only a function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga8b6ade329d6c1dbce2c67a94a58b2304" title="Allows zero-cost unordered expansion of a parameter. ">swallow</a> <a class="el" href="group__Utilities.html#gad65147320c04e61267089a58d71a6302" title="Perform a transform over a std::tuple. ">tuple_transform</a> <a class="el" href="group__Utilities.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple. ">tuple_fold</a> <a class="el" href="group__Utilities.html#ga3f67981c777b6762ada9da5ad5da11e7" title="Perform a fold over a std::tuple. ">tuple_counted_fold</a> <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

</div>
</div>
<a id="ga91227dc4aa14972b7b2e7070719d061b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91227dc4aa14972b7b2e7070719d061b">&#9670;&nbsp;</a></span>tuple_fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void tuple_fold </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_aryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a fold over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. </p>
<h3>Details</h3>
<p>Iterates over the elements in a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <code>tuple</code> from left to right (left fold) calling <code>op(element, args...)</code> on each element in <code>tuple</code>. A right fold can be done by explicitly setting the first template parameter to true. Folds are easily implemented using <code>tuple_fold</code> by updating one of the <code>args...</code> at each iteration. If you need the index of the current element you can use the <code>tuple_counted_fold</code> variant. <code>tuple_counted_fold</code> passes the current index as the second argument to the Callable <code>op</code>. That is, <code>op(element, index, args...)</code>.</p>
<h3>Example</h3>
<p>The sum of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> of Arithmetics can be computed in several ways. First, you can use a lambda: </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div><div class="line">    <span class="keywordtype">double</span> sum_value = 0.0;</div><div class="line">    <a class="code" href="group__Utilities.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a>(my_tupull,</div><div class="line">               [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element, <span class="keywordtype">double</span>&amp; state) { state += element; },</div><div class="line">               sum_value);</div><div class="line">    CHECK(sum_value == approx(26.1));</div></div><!-- fragment --><p>You'll notice that <code>state</code> is taken by reference and mutated.</p>
<p>You can do the same thing with a struct defined as </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>tuple_fold_plus {</div><div class="line">  T <a class="code" href="namespaceParallel.html#abe10bb124676f152e29c58c007b3b735">value</a> = 0.0;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;</div><div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> S&amp; element) {</div><div class="line">    value += element;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>and then using an instance of the struct </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div><div class="line">    tuple_fold_plus&lt;double&gt; sum_value{};</div><div class="line">    <a class="code" href="group__Utilities.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a>(my_tupull, sum_value);</div><div class="line">    CHECK(sum_value.value == approx(26.1));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You are not able to pass a function pointer to <code>tuple_fold</code> or <code>tuple_counted_fold</code> because you cannot pass a pointer to a function template, only a function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga8b6ade329d6c1dbce2c67a94a58b2304" title="Allows zero-cost unordered expansion of a parameter. ">swallow</a> <a class="el" href="group__Utilities.html#gad65147320c04e61267089a58d71a6302" title="Perform a transform over a std::tuple. ">tuple_transform</a> <a class="el" href="group__Utilities.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple. ">tuple_fold</a> <a class="el" href="group__Utilities.html#ga3f67981c777b6762ada9da5ad5da11e7" title="Perform a fold over a std::tuple. ">tuple_counted_fold</a> <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classCoordinateMap.html#a44481bbaa5fe5f8f86587d861e3760c7">CoordinateMap&lt; SourceFrame, TargetFrame, Maps &gt;::call_impl()</a>.</p>

</div>
</div>
<a id="gad65147320c04e61267089a58d71a6302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65147320c04e61267089a58d71a6302">&#9670;&nbsp;</a></span>tuple_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void tuple_transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_aryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a transform over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. </p>
<h3>Details</h3>
<p>Iterates over the elements in a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <code>tuple</code> from left to right calling <code>op.operator()(element, index, args...)</code> on each element in <code>tuple</code>. A right-to-left transform can be done by explicitly setting the first template parameter to true. The second argument of the invokable will be a deduced <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt;size_t, value&gt;</code>, from which the current index can be extracted by using <code>decltype(index)::value</code>. For a function object the <code>decltype(index)</code> can be replaced by the deduced type of <code>index</code>. For example, </p><div class="fragment"><div class="line"><span class="keyword">struct </span>negate {</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Index, <span class="keyword">typename</span> S&gt;</div><div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> T&amp; element, <a class="code" href="classIndex.html">Index</a> <span class="comment">/*index*/</span>,</div><div class="line">                  S&amp; second_tuple_element) <span class="keyword">const</span> noexcept {</div><div class="line">    std::get&lt;Index::value&gt;(second_tuple_element) = -element;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p> Using <code>tuple_transform</code> with a generic lambda goes as follows, </p><div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div><div class="line">  <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t&lt;decltype(my_tupull)&gt;</a> out_tupull;</div><div class="line">  <a class="code" href="group__Utilities.html#gad65147320c04e61267089a58d71a6302">tuple_transform</a>(my_tupull,</div><div class="line">                  [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element, <span class="keyword">auto</span> index, <span class="keyword">auto</span>&amp; out_tuple) {</div><div class="line">                    constexpr <span class="keywordtype">size_t</span> index_v = decltype(index)::<a class="code" href="namespaceParallel.html#abe10bb124676f152e29c58c007b3b735">value</a>;</div><div class="line">                    std::get&lt;index_v&gt;(out_tuple) = -element;</div><div class="line">                  },</div><div class="line">                  out_tupull);</div><div class="line"></div><div class="line">  CHECK(std::get&lt;0&gt;(out_tupull) == -2);</div><div class="line">  CHECK(std::get&lt;1&gt;(out_tupull) == -7);</div><div class="line">  CHECK(std::get&lt;2&gt;(out_tupull) == 3.8);</div><div class="line">  CHECK(std::get&lt;3&gt;(out_tupull) == -20.9);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga8b6ade329d6c1dbce2c67a94a58b2304" title="Allows zero-cost unordered expansion of a parameter. ">swallow</a> <a class="el" href="group__Utilities.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple. ">tuple_fold</a> <a class="el" href="group__Utilities.html#ga3f67981c777b6762ada9da5ad5da11e7" title="Perform a fold over a std::tuple. ">tuple_counted_fold</a> <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classCoordinateMap.html#a7d5854d873345464e9af44b74f0eaebf">CoordinateMap&lt; SourceFrame, TargetFrame, Maps &gt;::inv_jacobian_impl()</a>, and <a class="el" href="classCoordinateMap.html#a391c374cc28fab2facf98ddc22895803">CoordinateMap&lt; SourceFrame, TargetFrame, Maps &gt;::jacobian_impl()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gab78389fadf763e3693ce893fad5d7fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab78389fadf763e3693ce893fad5d7fba">&#9670;&nbsp;</a></span>flat_all_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tmpl2::flat_all_v = <a class="el" href="group__Utilities.html#ga01ee1794935080949a6995ae7d5e08cc">flat_all</a>&lt;Bs...&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical AND between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="el" href="structcpp17_1_1conjunction.html" title="A logical AND on the template parameters. ">cpp17::conjunction</a> and <a class="el" href="structcpp17_1_1disjunction.html" title="A logical OR on the template parameters. ">cpp17::disjunction</a> use recursion </p>

<p class="reference">Referenced by <a class="el" href="group__Utilities.html#ga18f579d55a04631539629be19103dcae">make_array()</a>.</p>

</div>
</div>
<a id="ga8a328cb983ebb1947b0eb9d924f40253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a328cb983ebb1947b0eb9d924f40253">&#9670;&nbsp;</a></span>flat_any_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tmpl2::flat_any_v = <a class="el" href="group__Utilities.html#ga6e25dbfa539ff4513329969dbcd81c40">flat_any</a>&lt;Bs...&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical OR between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="el" href="structcpp17_1_1conjunction.html" title="A logical AND on the template parameters. ">cpp17::conjunction</a> and <a class="el" href="structcpp17_1_1disjunction.html" title="A logical OR on the template parameters. ">cpp17::disjunction</a> use recursion </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
