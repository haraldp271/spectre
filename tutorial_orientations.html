<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.13"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Orientation</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "color.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
});
MathJax.Hub.Config({
    tex2jax: {inlineMath: [['^^','^^'], ['\\(', '\\)']]}
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
      SpECTRE &#160;
        <span id="projectnumber">v0.0.0</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Documentation</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown" style="min-width: 150px;">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Reference</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div><!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classOrientation.html" title="Allows one to construct a custom Orientation between two Blocks. ">Orientation</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h3>Orientations between Blocks</h3>
<p>The Orientations between Blocks are used to properly communicate fluxes across boundaries between adjacent Blocks that do not necessarily have their logical axes aligned. The <code><a class="el" href="classOrientation.html" title="Allows one to construct a custom Orientation between two Blocks. ">Orientation</a></code> class is used to keep track of which pair of axes in a pair of adjacent Blocks lie along the same physical direction at a boundary.</p>
<h3>Algorithms for determining the Orientation of Blocks given corners</h3>
<p>DomainHelpers is a collection of algorithms that are used to determine the Orientations between Blocks in a <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a> using a set of corner numbering schemes. The corner numberings must be determined and provided by the user. This tutorial will explain the corner numbering schemes used, and how to determine the correct corner numbering for a <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a>. We assume the user has a <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a> that has that has already been partitioned into Blocks in the form of a schematic diagram, and that the orientation of the logical axes within each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> has been determined before proceeding with this tutorial.</p>
<h3>Global Corner Numbering Scheme (Global CNS)</h3>
<p>The partitioning of the <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a> defines a global unordered set of corners. For example, a cubical <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a> which is partitioned equally into two Blocks has 12 corners; although each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> has 8 corners, 4 are shared among them. To assign a Global CNS to the <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a>, one may arbitrarily assign corner ids to each of the twelve corners in the <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a>, so long as each corner has a single, unique id.</p>
<dl class="section note"><dt>Note</dt><dd>This Global CNS assumes that there is no additional identifying of faces with one another for periodic boundary conditions. That is, that no block has itself as a neighbor. If you wish to additionally identify faces of the same block with each other, that must be done in an additional step. This step is explained in the "Setting Periodic Boundary Conditions" section.</dd></dl>
<h3>Local Corner Numbering Scheme (Local CNS)</h3>
<p>The orientation of the logical axes in each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> define an ordered set of corners. Once the logical axes in each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> are determined, it is possible to write down a Local CNS:</p>
<p>Each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> has \(2^{dim}\) local corners, numbered from \(0\) to \(2^{dim} - 1\). We will take the three-dimensional cube as an example: This <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> has 8 local corners (regardless how many of these are shared), numbered from 0 to 7. The corners are labelled according to the <a class="el" href="classCoordinateMap.html" title="A coordinate map or composition of coordinate maps. ">CoordinateMap</a> corresponding to the <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>, as follows:</p>
<div class="fragment"><div class="line">Corner 0 is the location of the lower xi, lower eta, lower zeta corner.</div><div class="line">Corner 1 is the location of the upper xi, lower eta, lower zeta corner.</div><div class="line">Corner 2 is the location of the lower xi, upper eta, lower zeta corner.</div><div class="line">Corner 3 is the location of the upper xi, upper eta, lower zeta corner.</div><div class="line">Corner 4 is the location of the lower xi, lower eta, upper zeta corner.</div><div class="line">Corner 5 is the location of the upper xi, lower eta, upper zeta corner.</div><div class="line">Corner 6 is the location of the lower xi, upper eta, upper zeta corner.</div><div class="line">Corner 7 is the location of the upper xi, upper eta, upper zeta corner.</div></div><!-- fragment --><p>We can summarize this information:</p>
<div class="fragment"><div class="line">Corner 0: 000</div><div class="line">Corner 1: 001</div><div class="line">Corner 2: 010</div><div class="line">Corner 3: 011</div><div class="line">Corner 4: 100</div><div class="line">Corner 5: 101</div><div class="line">Corner 6: 110</div><div class="line">Corner 7: 111</div></div><!-- fragment --><p>Where 0 and 1 indicate lower and upper in the corresponding axis (zeta, eta, xi), respectively, and the ordering has been reversed so that the rightmost column corresponds to the xi position and the leftmost column to the zeta position.</p>
<dl class="section note"><dt>Note</dt><dd>This Local CNS is independent of the Global CNS above.</dd></dl>
<h3>The Ordered Subset of the Global CNS (Subset CNS):</h3>
<p>With the Global CNS in hand, each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> inherits a ordered subset of Global CNS, the order determined by the ordering of the Local CNS, and the elements of the set determined by how one assigned the Global CNS to the <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a>. For example, if in a Global CNS one had assigned the id "7" to the lower xi, lower eta, lower zeta corner of a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>, then the Subset CNS corresponding to this <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> will begin as {7, ..., ...}. The Subset CNS encodes the relative Orientations between each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>.</p>
<p>The algorithms in DomainHelpers take these Subset CNSs as input, and from them determines the proper relative orientations between blocks.</p>
<h3>Explanation of the Algorithms in DomainHelpers:</h3>
<p>For illustrative purposes, we will use the following <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a> composed of two Blocks as described above as an example. Because there are 12 corners in this <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a>, we will arbitrarily assign a unique id to each corner. Knowing the orientation of the logical axes within a block, we construct a Subset CNS for each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>.<br />
 Here is one possible result, given some relative orientation between the blocks:</p>
<div class="fragment"><div class="line">Block1: {3,0,4,1,9,6,10,7}</div><div class="line">Block2: {1,2,4,5,7,8,10,11}</div></div><!-- fragment --><p>The values of the ids only serve to identify which corners are unique and which are shared. This is determined by the Global CNS. The order of the ids in the list is determined by the Local CNS. We take advantage of the fact that the array index of the global corner id is the number of the corner in the local CNS.</p>
<p>The algorithm begins by determining the shared corners between the Blocks:</p>
<div class="fragment"><div class="line">result: {4,1,10,7}</div></div><!-- fragment --><p>The next step is to determine the local ids of these shared global ids:</p>
<div class="fragment"><div class="line">Block1 result: {2,3,6,7}</div><div class="line">Block2 result: {2,0,6,4}</div></div><!-- fragment --><p>The next step is to convert these ids into their binary representation:</p>
<div class="fragment"><div class="line">Block1 result: {010,011,110,111}</div><div class="line">Block2 result: {010,000,110,100}</div></div><!-- fragment --><p>Note that we can now read off the shared face relative to each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> easily:</p>
<div class="fragment"><div class="line">Block1 result: Upper eta (All binary Block1 ids have a 1 in the second position)</div><div class="line">Block2 result: Lower xi (All binary Block2 ids have a 0 in the third position)</div></div><!-- fragment --><p>Now we know that <code><a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis. ">Direction</a>&lt;3&gt;::upper_eta()</code> in Block1 corresponds to <code><a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis. ">Direction</a>&lt;3&gt;::lower_xi().opposite()</code> in Block2.</p>
<p>The use of <code>.opposite()</code> is a result of the Directions to a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> face being anti-parallel because each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> lies on the opposite side of the shared face.<br />
</p>
<p>The remaining two correspondences are given by the Alignment of the shared face. It is useful to know the following information:<br />
 In the Local CNS, if an edge lies along the xi direction, if one takes the two corners making up that edge and takes the difference of their ids, one always gets the result \( \pm 1\). Similarly, if the edge lies in the eta direction, the result will be \( \pm 2\). Finally, if the edge lies in the zeta direction, the result will be \( \pm 4\). We use this information to determine the Alignment of the shared face:</p>
<div class="fragment"><div class="line">Block1: 3-2=1  =&gt; This edge is in the +xi direction.</div><div class="line">Block2: 0-2=-2 =&gt; This edge is in the -eta direction.</div><div class="line">Then, +xi in Block1 corresponds to -eta in Block2.</div><div class="line"></div><div class="line">Block1: 6-2=4 =&gt; This edge is in the +zeta direction.</div><div class="line">Block2: 6-2=4 =&gt; This edge is in the +zeta direction.</div><div class="line">Then, +zeta in Block1 corresponds to +zeta in Block2.</div></div><!-- fragment --><p>The corresponding directions in each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> have now been deduced.</p>
<p>To confirm, we can use the other ids as well and arrive at the same result:<br />
</p>
<div class="fragment"><div class="line">Block1: 7-6-1  =&gt; +xi</div><div class="line">Block2: 4-6=-2 =&gt; -eta</div><div class="line"></div><div class="line">Block1: 7-3=4  =&gt; +zeta</div><div class="line">Block2: 4-0=4  =&gt; +zeta</div></div><!-- fragment --><h3>Setting Periodic Boundary Conditions</h3>
<p>It is also possible to identify faces of a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> using the subset CNS. For example, to identify the lower zeta face with the upper zeta face of a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> where the corners are labeled <code>{3,0,4,1,9,6,10,7}</code>, one may supply the lists <code>{3,0,4,1}</code> and <code>{9,6,10,7}</code> to the <code>set_periodic_boundaries</code> function. </p><dl class="section note"><dt>Note</dt><dd>The <code>set_periodic_boundaries</code> function is sensitive to the order of the corners in the lists supplied as arguments. This is because the function identifies corners and edges with each other as opposed to simply faces. This allows the user to specify more peculiar boundary conditions. For example, using <code>{3,0,4,1}</code> and <code>{6,7,9,10}</code> to set the periodic boundaries will identify the lower zeta face with the upper zeta face, but after a rotation of a quarter-turn.</dd></dl>
<p>For reference, here are the corners to use for each face for a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> with corners labelled as <code>{0,1,2,3,4,5,6,7}</code> to set up periodic boundary conditions in each dimension, i.e. a \(\mathrm{T}^3\) topology:</p>
<table class="doxtable">
<tr>
<th>Face </th><th>Corners  </th></tr>
<tr>
<td>upper xi</td><td><code>{1,3,5,7}</code> </td></tr>
<tr>
<td>lower xi</td><td><code>{0,2,4,6}</code> </td></tr>
<tr>
<td>upper eta</td><td><code>{2,3,6,7}</code> </td></tr>
<tr>
<td>lower eta</td><td><code>{0,1,4,5}</code> </td></tr>
<tr>
<td>upper zeta</td><td><code>{4,5,6,7}</code> </td></tr>
<tr>
<td>lower zeta</td><td><code>{0,1,2,3}</code> </td></tr>
</table>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
