<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.13"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Parallelization</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "color.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
});
MathJax.Hub.Config({
    tex2jax: {inlineMath: [['^^','^^'], ['\\(', '\\)']]}
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
      SpECTRE &#160;
        <span id="projectnumber">v0.0.0</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Documentation</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown" style="min-width: 150px;">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Reference</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div><!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Parallelization</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions, classes and documentation related to parallelization and Charm++.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElementIndex.html">ElementIndex&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for indexing a Charm array by <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>.  <a href="classElementIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithmImpl_3_01ParallelComponent_00_01ChareType_00_01Metavariables_00_01tmpl_1_1list_3_05216f3256a498cdc6e28f87f21b55216.html">AlgorithmImpl&lt; ParallelComponent, ChareType, Metavariables, tmpl::list&lt; ActionsPack... &gt;, tmpl::list&lt; InboxTagsPack... &gt;, ArrayIndex, InitialDataBox &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A distributed object (Charm++ Chare) that executes a series of <a class="el" href="namespaceActions.html">Actions</a> and is capable of sending and receiving data. Acts as an interface to Charm++.  <a href="classAlgorithmImpl_3_01ParallelComponent_00_01ChareType_00_01Metavariables_00_01tmpl_1_1list_3_05216f3256a498cdc6e28f87f21b55216.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ArrayIndex.html">Parallel::ArrayIndex&lt; Index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array index used for indexing Chare Arrays, mostly an implementation detail.  <a href="structParallel_1_1ArrayIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1ConstGlobalCache.html">Parallel::ConstGlobalCache&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Charm++ chare that caches constant data once per Charm++ node.  <a href="classParallel_1_1ConstGlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1Main.html">Parallel::Main&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main function of a Charm++ executable.  <a href="classParallel_1_1Main.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ReductionData.html">Parallel::ReductionData&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for reducing heterogeneous collection of types in a single reduction call.  <a href="structParallel_1_1ReductionData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array__proxy.html">Parallel::is_array_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for an array chare.  <a href="structParallel_1_1is__array__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__chare__proxy.html">Parallel::is_chare_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a chare.  <a href="structParallel_1_1is__chare__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__group__proxy.html">Parallel::is_group_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a group chare.  <a href="structParallel_1_1is__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__node__group__proxy.html">Parallel::is_node_group_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a node group chare.  <a href="structParallel_1_1is__node__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__bound__array.html">Parallel::is_bound_array&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a ParallelComponent for a Charm++ bound array.  <a href="structParallel_1_1is__bound__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1has__pup__member.html">Parallel::has_pup_member&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> has a <code>pup</code> member function.  <a href="structParallel_1_1has__pup__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__pupable.html">Parallel::is_pupable&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type <code>T</code> has operator| defined for Charm++ serialization.  <a href="structParallel_1_1is__pupable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga54770b986b9c522da6d651e1be125a03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga54770b986b9c522da6d651e1be125a03">WRAPPED_PUPable_decl_template</a>(className)&#160;&#160;&#160;PUPable_decl_template(SINGLE_ARG(className))</td></tr>
<tr class="memdesc:ga54770b986b9c522da6d651e1be125a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark derived classes as serializable.  <a href="#ga54770b986b9c522da6d651e1be125a03">More...</a><br /></td></tr>
<tr class="separator:ga54770b986b9c522da6d651e1be125a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9eecd27ecadb3501ddae591bf07db0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#gade9eecd27ecadb3501ddae591bf07db0">WRAPPED_PUPable_decl_base_template</a>(baseClassName,  className)&#160;&#160;&#160;PUPable_decl_base_template(SINGLE_ARG(baseClassName), SINGLE_ARG(className))</td></tr>
<tr class="memdesc:gade9eecd27ecadb3501ddae591bf07db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark derived template classes as serializable.  <a href="#gade9eecd27ecadb3501ddae591bf07db0">More...</a><br /></td></tr>
<tr class="separator:gade9eecd27ecadb3501ddae591bf07db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaccc68e564135958d18110d2847dcc1b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#gaccc68e564135958d18110d2847dcc1b3">Parallel::abort</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;message)</td></tr>
<tr class="memdesc:gaccc68e564135958d18110d2847dcc1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the program with an error message.  <a href="group__Parallel.html#gaccc68e564135958d18110d2847dcc1b3">More...</a><br /></td></tr>
<tr class="separator:gaccc68e564135958d18110d2847dcc1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0397ccb72cb4205f5dc83d6f60d47d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#gad0397ccb72cb4205f5dc83d6f60d47d0">Parallel::lock</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CmiNodeLock *&gt; node_lock) noexcept</td></tr>
<tr class="memdesc:gad0397ccb72cb4205f5dc83d6f60d47d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a converse CmiNodeLock.  <a href="group__Parallel.html#gad0397ccb72cb4205f5dc83d6f60d47d0">More...</a><br /></td></tr>
<tr class="separator:gad0397ccb72cb4205f5dc83d6f60d47d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b5b8d712c472935e5c817e9ed723c25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga8b5b8d712c472935e5c817e9ed723c25">Parallel::try_lock</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CmiNodeLock *&gt; node_lock) noexcept</td></tr>
<tr class="memdesc:ga8b5b8d712c472935e5c817e9ed723c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the lock was successfully acquired and false if the lock is already acquired by another processor.  <a href="group__Parallel.html#ga8b5b8d712c472935e5c817e9ed723c25">More...</a><br /></td></tr>
<tr class="separator:ga8b5b8d712c472935e5c817e9ed723c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e5eb4933e796cd454b67ac773836f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga26e5eb4933e796cd454b67ac773836f9">Parallel::unlock</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CmiNodeLock *&gt; node_lock) noexcept</td></tr>
<tr class="memdesc:ga26e5eb4933e796cd454b67ac773836f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a converse CmiNodeLock.  <a href="group__Parallel.html#ga26e5eb4933e796cd454b67ac773836f9">More...</a><br /></td></tr>
<tr class="separator:ga26e5eb4933e796cd454b67ac773836f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca2773484152df4d8897024a244b3c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga8ca2773484152df4d8897024a244b3c0">Parallel::exit</a> ()</td></tr>
<tr class="memdesc:ga8ca2773484152df4d8897024a244b3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the program normally. This should only be called once over all processors.  <a href="group__Parallel.html#ga8ca2773484152df4d8897024a244b3c0">More...</a><br /></td></tr>
<tr class="separator:ga8ca2773484152df4d8897024a244b3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537d2cc78336566826c93c49f82746a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga537d2cc78336566826c93c49f82746a8">Parallel::number_of_procs</a> ()</td></tr>
<tr class="memdesc:ga537d2cc78336566826c93c49f82746a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements.  <a href="group__Parallel.html#ga537d2cc78336566826c93c49f82746a8">More...</a><br /></td></tr>
<tr class="separator:ga537d2cc78336566826c93c49f82746a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9537d2f88bafe61b07e0ceda735243ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga9537d2f88bafe61b07e0ceda735243ca">Parallel::my_proc</a> ()</td></tr>
<tr class="memdesc:ga9537d2f88bafe61b07e0ceda735243ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my processing element.  <a href="group__Parallel.html#ga9537d2f88bafe61b07e0ceda735243ca">More...</a><br /></td></tr>
<tr class="separator:ga9537d2f88bafe61b07e0ceda735243ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf999b9700ece84fca6cb82bb1ee9f3f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#gaf999b9700ece84fca6cb82bb1ee9f3f2">Parallel::number_of_nodes</a> ()</td></tr>
<tr class="memdesc:gaf999b9700ece84fca6cb82bb1ee9f3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes.  <a href="group__Parallel.html#gaf999b9700ece84fca6cb82bb1ee9f3f2">More...</a><br /></td></tr>
<tr class="separator:gaf999b9700ece84fca6cb82bb1ee9f3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f24e1c6dfcfa4e9250a165973b1a524"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga9f24e1c6dfcfa4e9250a165973b1a524">Parallel::my_node</a> ()</td></tr>
<tr class="memdesc:ga9f24e1c6dfcfa4e9250a165973b1a524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my node.  <a href="group__Parallel.html#ga9f24e1c6dfcfa4e9250a165973b1a524">More...</a><br /></td></tr>
<tr class="separator:ga9f24e1c6dfcfa4e9250a165973b1a524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9459395dbb2a65f0d0b0439387067a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#gab9459395dbb2a65f0d0b0439387067a1">Parallel::procs_on_node</a> (const int node_index)</td></tr>
<tr class="memdesc:gab9459395dbb2a65f0d0b0439387067a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements on the given node.  <a href="group__Parallel.html#gab9459395dbb2a65f0d0b0439387067a1">More...</a><br /></td></tr>
<tr class="separator:gab9459395dbb2a65f0d0b0439387067a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0899b00614f1c47c6b32d1f83976a23b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga0899b00614f1c47c6b32d1f83976a23b">Parallel::my_local_rank</a> ()</td></tr>
<tr class="memdesc:ga0899b00614f1c47c6b32d1f83976a23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index of my processing element on my node. This is in the interval 0, ..., procs_on_node(my_node()) - 1.  <a href="group__Parallel.html#ga0899b00614f1c47c6b32d1f83976a23b">More...</a><br /></td></tr>
<tr class="separator:ga0899b00614f1c47c6b32d1f83976a23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f2f2d9db4aca7b4f11370e1556b43a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga6f2f2d9db4aca7b4f11370e1556b43a5">Parallel::first_proc_on_node</a> (const int node_index)</td></tr>
<tr class="memdesc:ga6f2f2d9db4aca7b4f11370e1556b43a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of first processing element on the given node.  <a href="group__Parallel.html#ga6f2f2d9db4aca7b4f11370e1556b43a5">More...</a><br /></td></tr>
<tr class="separator:ga6f2f2d9db4aca7b4f11370e1556b43a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga042f8935c6008898b980065058d0d8e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga042f8935c6008898b980065058d0d8e2">Parallel::node_of</a> (const int proc_index)</td></tr>
<tr class="memdesc:ga042f8935c6008898b980065058d0d8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the node for the given processing element.  <a href="group__Parallel.html#ga042f8935c6008898b980065058d0d8e2">More...</a><br /></td></tr>
<tr class="separator:ga042f8935c6008898b980065058d0d8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab13a71393339d7f35a3f802df360429b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#gab13a71393339d7f35a3f802df360429b">Parallel::local_rank_of</a> (const int proc_index)</td></tr>
<tr class="memdesc:gab13a71393339d7f35a3f802df360429b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index for the given processing element on its node.  <a href="group__Parallel.html#gab13a71393339d7f35a3f802df360429b">More...</a><br /></td></tr>
<tr class="separator:gab13a71393339d7f35a3f802df360429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62feba0b73433140761dad9a3127b998"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga62feba0b73433140761dad9a3127b998">Parallel::wall_time</a> ()</td></tr>
<tr class="memdesc:ga62feba0b73433140761dad9a3127b998"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current wall time in seconds.  <a href="group__Parallel.html#ga62feba0b73433140761dad9a3127b998">More...</a><br /></td></tr>
<tr class="separator:ga62feba0b73433140761dad9a3127b998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Parallel.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;format, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gae21964b5d28608afd21ae090c1c4c073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an atomic message to stdout with C printf usage.  <a href="group__Parallel.html#gae21964b5d28608afd21ae090c1c4c073">More...</a><br /></td></tr>
<tr class="separator:gae21964b5d28608afd21ae090c1c4c073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf7c761da739f9402e05c2f0edfbbd0b"><td class="memTemplParams" colspan="2">template&lt;size_t Index, class... Us&gt; </td></tr>
<tr class="memitem:gacf7c761da739f9402e05c2f0edfbbd0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Parallel.html#gacf7c761da739f9402e05c2f0edfbbd0b">Parallel::get</a> (<a class="el" href="structParallel_1_1ReductionData.html">ReductionData</a>&lt; Us... &gt; &amp;reduction_data) noexcept -&gt; decltype(std::get&lt; <a class="el" href="classIndex.html">Index</a> &gt;(reduction_data.data))</td></tr>
<tr class="memdesc:gacf7c761da739f9402e05c2f0edfbbd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="classIndex.html" title="An integer multi-index. ">Index</a></code>th element from a <code><a class="el" href="structParallel_1_1ReductionData.html" title="Used for reducing heterogeneous collection of types in a single reduction call. ">ReductionData</a>&lt;Ts...&gt;</code>, similar to <code>std::get</code> for <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></code>s.  <a href="group__Parallel.html#gacf7c761da739f9402e05c2f0edfbbd0b">More...</a><br /></td></tr>
<tr class="separator:gacf7c761da739f9402e05c2f0edfbbd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239d2b86392c74f5963bc6e2db1d48ac"><td class="memTemplParams" colspan="2">template&lt;class SenderParallelComponent , class TargetParallelComponent , class Action , class Metavariables , class ArrayIndex , class ReductionType , Requires&lt; not Parallel_detail::is_custom_reduction_type_v&lt; ReductionType &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga239d2b86392c74f5963bc6e2db1d48ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga239d2b86392c74f5963bc6e2db1d48ac">Parallel::contribute_to_reduction</a> (const <a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;cache, const <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a> &amp;array_index, CkReduction::reducerType reducer, const ReductionType &amp;reduction_data) noexcept</td></tr>
<tr class="memdesc:ga239d2b86392c74f5963bc6e2db1d48ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a reduction from the current ParallelComponent to the <code>TargetParallelComponent</code>, performing the <code>Action</code> upon receiving the reduction.  <a href="group__Parallel.html#ga239d2b86392c74f5963bc6e2db1d48ac">More...</a><br /></td></tr>
<tr class="separator:ga239d2b86392c74f5963bc6e2db1d48ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487910432c5ea8b35c12eb721c4afabe"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:ga487910432c5ea8b35c12eb721c4afabe"><td class="memTemplItemLeft" align="right" valign="top">CkReductionMsg *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga487910432c5ea8b35c12eb721c4afabe">Parallel::new_reduction_msg</a> (<a class="el" href="structParallel_1_1ReductionData.html">ReductionData</a>&lt; Ts... &gt; &amp;reduction_data) noexcept</td></tr>
<tr class="memdesc:ga487910432c5ea8b35c12eb721c4afabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <code><a class="el" href="structParallel_1_1ReductionData.html" title="Used for reducing heterogeneous collection of types in a single reduction call. ">ReductionData</a></code> to a <code>CkReductionMsg</code>. Used in custom reducers.  <a href="group__Parallel.html#ga487910432c5ea8b35c12eb721c4afabe">More...</a><br /></td></tr>
<tr class="separator:ga487910432c5ea8b35c12eb721c4afabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf46b590510bd8fad34c7055079262707"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaf46b590510bd8fad34c7055079262707"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Parallel.html#gaf46b590510bd8fad34c7055079262707">serialize</a> (const U &amp;obj)</td></tr>
<tr class="memdesc:gaf46b590510bd8fad34c7055079262707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an object using PUP.  <a href="#gaf46b590510bd8fad34c7055079262707">More...</a><br /></td></tr>
<tr class="separator:gaf46b590510bd8fad34c7055079262707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga6fb3864413e851ea6dcd1ffa319f2f25">deserialize</a> (const void *const data)</td></tr>
<tr class="memdesc:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an object using PUP.  <a href="#ga6fb3864413e851ea6dcd1ffa319f2f25">More...</a><br /></td></tr>
<tr class="separator:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb449233b977a5a9a4e218f148a2079"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:gadfb449233b977a5a9a4e218f148a2079"><td class="memTemplItemLeft" align="right" valign="top">Parallel::proxy_from_parallel_component&lt; ParallelComponentTag &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Parallel.html#gadfb449233b977a5a9a4e218f148a2079">Parallel::get_parallel_component</a> (<a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;cache) noexcept</td></tr>
<tr class="memdesc:gadfb449233b977a5a9a4e218f148a2079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__Parallel.html#gadfb449233b977a5a9a4e218f148a2079">More...</a><br /></td></tr>
<tr class="separator:gadfb449233b977a5a9a4e218f148a2079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1733d08fcae58c687bbe53bc7337d159"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga1733d08fcae58c687bbe53bc7337d159"><td class="memTemplItemLeft" align="right" valign="top">const Parallel::proxy_from_parallel_component&lt; ParallelComponentTag &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga1733d08fcae58c687bbe53bc7337d159">Parallel::get_parallel_component</a> (const <a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;cache) noexcept</td></tr>
<tr class="memdesc:ga1733d08fcae58c687bbe53bc7337d159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__Parallel.html#ga1733d08fcae58c687bbe53bc7337d159">More...</a><br /></td></tr>
<tr class="separator:ga1733d08fcae58c687bbe53bc7337d159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ab0de2c7809926d565671512f706126"><td class="memTemplParams" colspan="2">template&lt;typename ConstGlobalCacheTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga8ab0de2c7809926d565671512f706126"><td class="memTemplItemLeft" align="right" valign="top">const ConstGlobalCache_detail::type_for_get&lt; typename ConstGlobalCacheTag::type &gt;::<a class="el" href="namespaceParallel.html#aa818bfd01f755b6e721a2c1f0aa075bf">type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Parallel.html#ga8ab0de2c7809926d565671512f706126">Parallel::get</a> (const <a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;cache) noexcept</td></tr>
<tr class="memdesc:ga8ab0de2c7809926d565671512f706126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access data in the cache.  <a href="group__Parallel.html#ga8ab0de2c7809926d565671512f706126">More...</a><br /></td></tr>
<tr class="separator:ga8ab0de2c7809926d565671512f706126"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions, classes and documentation related to parallelization and Charm++. </p>
<p>SpECTRE builds a layer on top of Charm++ that performs various safety checks and initialization for the user that can otherwise lead to difficult to debug undefined behavior. The central concept is what is called a Parallel Component. A Parallel Component is a struct with several type aliases that is used by SpECTRE to set up the Charm++ chares and allowed communication patterns. It might be most natural to think of Parallel Components as input arguments to a metaprogram that writes the parallelization infrastructure that you requested for the executable. There is no restriction on the number of Parallel Components, though practically it is best to have around 10 at most.</p>
<p>Each Parallel Component must have the following type aliases:</p><ol type="1">
<li><code>using chare_type</code> is set to one of <code>Parallel::Algorithms::Singleton</code>, <code>Parallel::Algorithms::Array</code>, <code>Parallel::Algorithms::Group</code>, or <code>Parallel::Algorithms::Nodegroup</code>. What these mean is explained below.</li>
<li><code>using metavariables</code> is set to the Metavariables struct that stores the global metavariables. It is often easiest to have the Parallel Component struct have a template parameter <code>Metavariables</code> that is the global metavariables struct. Examples of this are given below.</li>
<li><code>using action_list</code> is set to a <code>typelist</code> of the <a class="el" href="namespaceActions.html">Actions</a> that the Algorithm running on the Parallel Component executes. The <a class="el" href="namespaceActions.html">Actions</a> are executed in the order that they are listed in in the typelist.</li>
<li><code>using inbox_tag_list</code> is set to a typelist of the <a class="el" href="namespaceTags.html">Tags</a> that can be sent to the Parallel Component by calling the <code>receive_data</code> method. If the Inbox Tag needs to have some temporal locality, then an optional type alias <code>temporal_id</code> must be specified in the Inbox Tag and sent along with the data.</li>
<li><code>using initial_databox</code> is set to the type of the DataBox that will be passed to the first Action of the <code>action_list</code>. Typically it is the output of some <code>explicit_single_action</code> call made during the <code>initialize</code> function. More on this below.</li>
<li><code>using options</code> is set to a (possibly empty) typelist of the option structs which are read in from the input file specified in the main <code>Metavariables</code> struct and passed to the <code>initialize</code> function described below.</li>
</ol>
<p>The following type aliases are not always required, but will be in some circumstances:</p><ol type="1">
<li><code>using array_index</code> is set to the type that indexes the Parallel Component Array and is only required if <code>chare_type = Parallel::Algorithms::Array</code>. Charm++ allows arrays to be 1 through 6 dimensional or be indexed by a custom type. The Charm++ provided indexes are wrapped as `Parallel::ArrayIndex1D' through <code><a class="el" href="namespaceParallel.html#a0b2d628261f946a0f57d2e9cb90efe3d">Parallel::ArrayIndex6D</a></code>. When writing custom array indices, the Charm++ manual tells you to write your own <code>CkArrayIndex</code>, but we have written a general implementation that provides this functionality; all that you need to provide is a plain-old-data struct of the size of at most 3 integers.</li>
<li><code>using explicit_single_actions</code> is set to a typelist of typelists for <a class="el" href="namespaceActions.html">Actions</a> that are not part of the algorithm but can be called remotely at any time, similar in spirit to a member function. For each Action, a typelist is specified with the Action as their first element, and the remaining elements are types of the data that is sent to the Parallel Component and passed into the Action.</li>
<li><code>using reduction_actions_list</code> is set to a typelist of typelists. The nested typelists must have exactly two elements. The first element is the Action to call, and the second is the type being reduced. For example, the reduced type could be an <code>int</code>, a <code>double</code>, or a specialization of <code><a class="el" href="structParallel_1_1ReductionData.html" title="Used for reducing heterogeneous collection of types in a single reduction call. ">Parallel::ReductionData</a></code>.</li>
</ol>
<p>Parallel Components must also have two static member functions with the following signatures:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> initialize(</div><div class="line">   Parallel::CProxy_ConstGlobalCache&lt;metavariables&gt;&amp; global_cache, opts...);</div></div><!-- fragment --><p>and</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> execute_next_global_actions(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> metavariables::Phase next_phase,</div><div class="line">    <span class="keyword">const</span> Parallel::CProxy_ConstGlobalCache&lt;metavariables&gt;&amp; global_cache);</div></div><!-- fragment --><p>The <code>initialize</code> function is called by the Main Parallel Component when the execution starts and will typically call an explicit single Action to set up the initial state of the Algorithm, similar to what a constructor does for classes. The <code>initialize</code> function also receives arguments that are read from the input file and can the be used to initialize the Parallel Component. For example, the value of an option could be distributed to all members of a Parallel Component Array, or could be used to control the size of the Parallel Component Array.</p>
<p>The <code>execute_next_global_actions</code> function gets run at the end of each Parallel Phase and determines what the Parallel Component should do during the next phase. For example, it may simply call <code>perform_algorithm</code>, call a series of single <a class="el" href="namespaceActions.html">Actions</a>, perform a reduction over an Array, or not do anything at all.</p>
<p>An example of a singleton Parallel Component is:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Metavariables&gt;</div><div class="line"><span class="keyword">struct </span>SingletonParallelComponent {</div><div class="line">  <span class="keyword">using</span> chare_type = Parallel::Algorithms::Singleton;</div><div class="line">  <span class="keyword">using</span> const_global_cache_tag_list = <a class="code" href="group__Utilities.html#ga4dabf6319ff36d72095831fba701afc1">typelist&lt;&gt;</a>;</div><div class="line">  <span class="keyword">using</span> metavariables = Metavariables;</div><div class="line">  <span class="keyword">using</span> action_list = <a class="code" href="group__Utilities.html#ga4dabf6319ff36d72095831fba701afc1">typelist&lt;SingletonActions::CountReceives&gt;</a>;</div><div class="line">  <span class="keyword">using</span> inbox_tag_list = <a class="code" href="group__Utilities.html#ga4dabf6319ff36d72095831fba701afc1">typelist&lt;Tags::IntReceiveTag&gt;</a>;</div><div class="line">  <span class="keyword">using</span> initial_databox = db::DataBox&lt;db::get_databox_list&lt;typelist&lt;&gt;&gt;&gt;;</div><div class="line">  <span class="keyword">using</span> explicit_single_actions_list =</div><div class="line">      tmpl::list&lt;tmpl::list&lt;SingletonActions::Initialize&gt;&gt;;</div><div class="line">  <span class="keyword">using</span> options = <a class="code" href="group__Utilities.html#ga4dabf6319ff36d72095831fba701afc1">typelist&lt;&gt;</a>;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> initialize(</div><div class="line">      Parallel::CProxy_ConstGlobalCache&lt;Metavariables&gt;&amp; global_cache) {</div><div class="line">    <span class="keyword">auto</span>&amp; local_cache = *(global_cache.ckLocalBranch());</div><div class="line">    Parallel::get_parallel_component&lt;SingletonParallelComponent&gt;(local_cache)</div><div class="line">        .<span class="keyword">template</span> explicit_single_action&lt;SingletonActions::Initialize&gt;();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> execute_next_global_actions(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> Metavariables::Phase next_phase,</div><div class="line">      <span class="keyword">const</span> Parallel::CProxy_ConstGlobalCache&lt;Metavariables&gt;&amp; global_cache) {</div><div class="line">    <span class="keywordflow">if</span> (next_phase == Metavariables::Phase::PerformSingletonAlgorithm) {</div><div class="line">      <span class="keyword">auto</span>&amp; local_cache = *(global_cache.ckLocalBranch());</div><div class="line">      Parallel::get_parallel_component&lt;SingletonParallelComponent&gt;(local_cache)</div><div class="line">          .perform_algorithm();</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p> and similarly of a Parallel Component Array:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Metavariables&gt;</div><div class="line"><span class="keyword">struct </span>ArrayParallelComponent {</div><div class="line">  <span class="keyword">using</span> chare_type = Parallel::Algorithms::Array;</div><div class="line">  <span class="keyword">using</span> const_global_cache_tag_list = <a class="code" href="group__Utilities.html#ga4dabf6319ff36d72095831fba701afc1">typelist&lt;&gt;</a>;</div><div class="line">  <span class="keyword">using</span> metavariables = Metavariables;</div><div class="line">  <span class="keyword">using</span> action_list =</div><div class="line">      <a class="code" href="group__Utilities.html#ga4dabf6319ff36d72095831fba701afc1">typelist</a>&lt;ArrayActions::AddIntValue10, ArrayActions::IncrementInt0,</div><div class="line">               ArrayActions::RemoveInt0, ArrayActions::SendToSingleton&gt;;</div><div class="line">  <span class="keyword">using</span> inbox_tag_list = <a class="code" href="group__Utilities.html#ga4dabf6319ff36d72095831fba701afc1">typelist&lt;Tags::IntReceiveTag&gt;</a>;</div><div class="line">  <span class="keyword">using</span> array_index = int;</div><div class="line">  <span class="keyword">using</span> initial_databox =</div><div class="line">      db::DataBox&lt;db::get_databox_list&lt;typelist&lt;Tags::CountActionsCalled&gt;&gt;&gt;;</div><div class="line"></div><div class="line">  <span class="keyword">using</span> explicit_single_actions_list =</div><div class="line">      tmpl::list&lt;tmpl::list&lt;ArrayActions::Initialize&gt;&gt;;</div><div class="line">  <span class="keyword">using</span> options = <a class="code" href="group__Utilities.html#ga4dabf6319ff36d72095831fba701afc1">typelist&lt;&gt;</a>;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> initialize(</div><div class="line">      Parallel::CProxy_ConstGlobalCache&lt;Metavariables&gt;&amp; global_cache) {</div><div class="line">    <span class="keyword">auto</span>&amp; local_cache = *(global_cache.ckLocalBranch());</div><div class="line">    <span class="keyword">auto</span>&amp; array_proxy =</div><div class="line">        Parallel::get_parallel_component&lt;ArrayParallelComponent&gt;(local_cache);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="namespacetnsr.html#ac7a4fa718be18533f5e2727e09f10704">i</a> = 0, which_proc = 0,</div><div class="line">             <a class="code" href="group__Parallel.html#ga537d2cc78336566826c93c49f82746a8">number_of_procs</a> = <a class="code" href="group__Parallel.html#ga537d2cc78336566826c93c49f82746a8">Parallel::number_of_procs</a>();</div><div class="line">         <a class="code" href="namespacetnsr.html#ac7a4fa718be18533f5e2727e09f10704">i</a> &lt; number_of_1d_array_elements; ++<a class="code" href="namespacetnsr.html#ac7a4fa718be18533f5e2727e09f10704">i</a>) {</div><div class="line">      array_proxy[<a class="code" href="namespacetnsr.html#ac7a4fa718be18533f5e2727e09f10704">i</a>].insert(global_cache, which_proc);</div><div class="line">      which_proc = which_proc + 1 == <a class="code" href="group__Parallel.html#ga537d2cc78336566826c93c49f82746a8">number_of_procs</a> ? 0 : which_proc + 1;</div><div class="line">    }</div><div class="line">    array_proxy.doneInserting();</div><div class="line"></div><div class="line">    array_proxy.template explicit_single_action&lt;ArrayActions::Initialize&gt;();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> execute_next_global_actions(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> Metavariables::Phase next_phase,</div><div class="line">      Parallel::CProxy_ConstGlobalCache&lt;Metavariables&gt;&amp; global_cache) {</div><div class="line">    <span class="keyword">auto</span>&amp; local_cache = *(global_cache.ckLocalBranch());</div><div class="line">    <span class="keywordflow">if</span> (next_phase == Metavariables::Phase::PerformArrayAlgorithm) {</div><div class="line">      Parallel::get_parallel_component&lt;ArrayParallelComponent&gt;(local_cache)</div><div class="line">          .perform_algorithm();</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p> Elements are inserted into the Array by using the Charm++ <code>insert</code> member function of the CProxy for the array. The <code>insert</code> function is is documented in the Charm++ manual. In the above Array example <code>array_proxy</code> is a <code>CProxy</code> to the <code>AlgorithmImpl&lt;Parallel::Algorithms::Array, ...&gt;</code> and so all the documentation for Charm++ array proxies applies. We always create empty Arrays with the constructor and require users to insert however many elements they want and on which cores they want them to be placed. Note that load balancing calls may result in Array elements being moved.</p>
<p>There are four types of Algorithms with one Algorithm object per Charm++ chare object. The four types of Algorithms are:</p><ol type="1">
<li>A Parallel::Algorithms::Singleton where there is only one object in the entire execution of the program.</li>
<li>A Parallel::Algorithms::Array which holds zero or more elements each of which is an object distributed to some core. An array can grow and shrink in size dynamically if need be and can also be bound to another array. A bound array has the same number of elements as the array it is bound to, and elements with the same ID are on the same core. See Charm++'s chare arrays for details.</li>
<li>A Parallel::Algorithms::Group is an array with one element per core which are not able to be moved around between cores. These are typically useful for gathering data from array elements on their core, and then processing or reducing it. See Charm++'s group chares for details</li>
<li>A Parallel::Algorithms::Nodegroup, which is similar to a group except that there is one element per node. For Charm++ SMP (shared memory parallelism) builds a node corresponds to the usual definition of a node on a supercomputer. However, for non-SMP builds nodes and cores are equivalent. We ensure that all entry method calls done through the Algorithm's <code>explicit_single_action</code> and <code>receive_data</code> functions are threadsafe. User controlled threading is possible by calling the non-entry method member function <code>threaded_single_action</code>.</li>
</ol>
<h3>Entry Methods and Remote Function Invocation</h3>
<p>Charm++ refers to functions that can be called remotely as entry methods. The <a class="el" href="namespaceParallel.html" title="Contains functions that forward to Charm++ parallel functions. ">Parallel</a> Components provide several generic entry methods. These fall into two classes:</p><ol type="1">
<li>Entry methods that perform a single Action once</li>
<li>Entry methods that iterate the <a class="el" href="namespaceActions.html">Actions</a> in the Algorithm's <code>action_list</code>. </li>
</ol>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gade9eecd27ecadb3501ddae591bf07db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9eecd27ecadb3501ddae591bf07db0">&#9670;&nbsp;</a></span>WRAPPED_PUPable_decl_base_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WRAPPED_PUPable_decl_base_template</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">baseClassName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">className&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;PUPable_decl_base_template(SINGLE_ARG(baseClassName), SINGLE_ARG(className))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark derived template classes as serializable. </p>
<p>Any class that derives off of a class template base class must contain this macro if it is to be serialized. </p>

<p class="reference">Referenced by <a class="el" href="classCoordinateMap.html#a616ffeaa05b9a4c3e383a28929903070">CoordinateMap&lt; SourceFrame, TargetFrame, Maps &gt;::jacobian()</a>.</p>

</div>
</div>
<a id="ga54770b986b9c522da6d651e1be125a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54770b986b9c522da6d651e1be125a03">&#9670;&nbsp;</a></span>WRAPPED_PUPable_decl_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WRAPPED_PUPable_decl_template</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">className</td><td>)</td>
          <td>&#160;&#160;&#160;PUPable_decl_template(SINGLE_ARG(className))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark derived classes as serializable. </p>
<p>Any class that derives off of a non-class template base class must contain this macro if it is to be serialized. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaccc68e564135958d18110d2847dcc1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccc68e564135958d18110d2847dcc1b3">&#9670;&nbsp;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::abort </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abort the program with an error message. </p>

<p class="reference">Referenced by <a class="el" href="group__ErrorHandling.html#ga976ceeca531715395cf8b0cb9664fbc7">abort_with_error_message()</a>, and <a class="el" href="InitializationFunctions_8hpp.html#a3c6ed8b0f0ebe0602662b224d84c0e0c">setup_error_handling()</a>.</p>

</div>
</div>
<a id="ga239d2b86392c74f5963bc6e2db1d48ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga239d2b86392c74f5963bc6e2db1d48ac">&#9670;&nbsp;</a></span>contribute_to_reduction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SenderParallelComponent , class TargetParallelComponent , class Action , class Metavariables , class ArrayIndex , class ReductionType , Requires&lt; not Parallel_detail::is_custom_reduction_type_v&lt; ReductionType &gt;&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::contribute_to_reduction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structParallel_1_1ArrayIndex.html">ArrayIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>array_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CkReduction::reducerType&#160;</td>
          <td class="paramname"><em>reducer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReductionType &amp;&#160;</td>
          <td class="paramname"><em>reduction_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a reduction from the current ParallelComponent to the <code>TargetParallelComponent</code>, performing the <code>Action</code> upon receiving the reduction. </p>
<p>The function must receive a <code><a class="el" href="classParallel_1_1ConstGlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node. ">ConstGlobalCache</a></code> and <code><a class="el" href="structParallel_1_1ArrayIndex.html" title="The array index used for indexing Chare Arrays, mostly an implementation detail. ">ArrayIndex</a></code> of the sending ParallelComponent. A Charm++ reducer specifying what type of reduction is to be done must also be passed (see <a href="http://charm.cs.illinois.edu/manuals/html/charm++/manual.html">here</a>), as well as the data that is to be reduced.</p>
<h3>Example</h3>
<p>Built-in Charm++ reductions are supported as: </p><div class="fragment"><div class="line">    Parallel::contribute_to_reduction&lt;ArrayParallelComponent&lt;Metavariables&gt;,</div><div class="line">                                      SingletonParallelComponent&lt;Metavariables&gt;,</div><div class="line">                                      singleton_reduce_sum_int&gt;(</div><div class="line">        cache, array_index, CkReduction::sum_int, my_send_int);</div></div><!-- fragment --><p>and similarly custom reductions: </p><div class="fragment"><div class="line">    Parallel::contribute_to_reduction&lt;ArrayParallelComponent&lt;Metavariables&gt;,</div><div class="line">                                      SingletonParallelComponent&lt;Metavariables&gt;,</div><div class="line">                                      singleton_reduce_custom_reduction&gt;(</div><div class="line">        cache, array_index, reduction_data_reducer,</div><div class="line">        <a class="code" href="structParallel_1_1ReductionData.html">Parallel::ReductionData&lt;int, std::unordered_map&lt;std::string, int&gt;</a>,</div><div class="line">                                <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;int&gt;</a>&gt;{</div><div class="line">            10, std::move(my_send_map), <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;int&gt;</a>{array_index, 10, -8}});</div></div><!-- fragment -->
</div>
</div>
<a id="ga6fb3864413e851ea6dcd1ffa319f2f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fb3864413e851ea6dcd1ffa319f2f25">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T deserialize </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize an object using PUP. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to deserialize to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ca2773484152df4d8897024a244b3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ca2773484152df4d8897024a244b3c0">&#9670;&nbsp;</a></span>exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exit the program normally. This should only be called once over all processors. </p>

<p class="reference">Referenced by <a class="el" href="classParallel_1_1Main.html#a4a48dd14fcfdef965d95ecdbfda2b64c">Parallel::Main&lt; Metavariables &gt;::execute_next_phase()</a>, and <a class="el" href="classParallel_1_1Main.html#ad31bce8155c9f055625469506748204f">Parallel::Main&lt; Metavariables &gt;::Main()</a>.</p>

</div>
</div>
<a id="ga6f2f2d9db4aca7b4f11370e1556b43a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f2f2d9db4aca7b4f11370e1556b43a5">&#9670;&nbsp;</a></span>first_proc_on_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Parallel::first_proc_on_node </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of first processing element on the given node. </p>

</div>
</div>
<a id="gacf7c761da739f9402e05c2f0edfbbd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf7c761da739f9402e05c2f0edfbbd0b">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Index, class... Us&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Parallel::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParallel_1_1ReductionData.html">ReductionData</a>&lt; Us... &gt; &amp;&#160;</td>
          <td class="paramname"><em>reduction_data</em></td><td>)</td>
          <td> -&gt; decltype(std::get&lt;<a class="el" href="classIndex.html">Index</a>&gt;(reduction_data.data)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="classIndex.html" title="An integer multi-index. ">Index</a></code>th element from a <code><a class="el" href="structParallel_1_1ReductionData.html" title="Used for reducing heterogeneous collection of types in a single reduction call. ">ReductionData</a>&lt;Ts...&gt;</code>, similar to <code>std::get</code> for <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></code>s. </p>
<dl class="section note"><dt>Note</dt><dd>Also available for rvalue and const references </dd></dl>

</div>
</div>
<a id="ga8ab0de2c7809926d565671512f706126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ab0de2c7809926d565671512f706126">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstGlobalCacheTag , typename Metavariables &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ConstGlobalCache_detail::type_for_get&lt; typename ConstGlobalCacheTag::type&gt;::<a class="el" href="namespaceParallel.html#aa818bfd01f755b6e721a2c1f0aa075bf">type</a>&amp; Parallel::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access data in the cache. </p>
<p><em>Requires:</em> ConstGlobalCacheTag is a tag in tag_list</p>
<p><em>Returns:</em> a constant reference to an object in the cache </p>

<p class="reference">References <a class="el" href="group__Utilities.html#gad87825ee8984324e81a2ae6ab2fec6ed">make_overloader()</a>.</p>

</div>
</div>
<a id="gadfb449233b977a5a9a4e218f148a2079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfb449233b977a5a9a4e218f148a2079">&#9670;&nbsp;</a></span>get_parallel_component() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponentTag , typename Metavariables &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parallel::proxy_from_parallel_component&lt;ParallelComponentTag&gt;&amp; Parallel::get_parallel_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the Charm++ proxy associated with a ParallelComponent. </p>
<p><em>Requires:</em> ParallelComponentTag is a tag in component_list</p>
<p><em>Returns:</em> a Charm++ proxy that can be used to call an entry method on the chare(s) </p>

<p class="reference">References <a class="el" href="group__Utilities.html#gaf29c2fe540b02e47a11c1ff9287bf169">tuples::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classParallel_1_1ConstGlobalCache.html#a8d3c44f92d97e98d9a6b6f9d1cb8f000">Parallel::ConstGlobalCache&lt; Metavariables &gt;::ConstGlobalCache()</a>.</p>

</div>
</div>
<a id="ga1733d08fcae58c687bbe53bc7337d159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1733d08fcae58c687bbe53bc7337d159">&#9670;&nbsp;</a></span>get_parallel_component() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponentTag , typename Metavariables &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Parallel::proxy_from_parallel_component&lt;ParallelComponentTag&gt;&amp; Parallel::get_parallel_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the Charm++ proxy associated with a ParallelComponent. </p>
<p><em>Requires:</em> ParallelComponentTag is a tag in component_list</p>
<p><em>Returns:</em> a Charm++ proxy that can be used to call an entry method on the chare(s) </p>

<p class="reference">References <a class="el" href="group__Utilities.html#gaf29c2fe540b02e47a11c1ff9287bf169">tuples::get()</a>.</p>

</div>
</div>
<a id="gab13a71393339d7f35a3f802df360429b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab13a71393339d7f35a3f802df360429b">&#9670;&nbsp;</a></span>local_rank_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Parallel::local_rank_of </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>proc_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The local index for the given processing element on its node. </p>

</div>
</div>
<a id="gad0397ccb72cb4205f5dc83d6f60d47d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0397ccb72cb4205f5dc83d6f60d47d0">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CmiNodeLock *&gt;&#160;</td>
          <td class="paramname"><em>node_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock a converse CmiNodeLock. </p>

<p class="reference">Referenced by <a class="el" href="classAlgorithmImpl_3_01ParallelComponent_00_01ChareType_00_01Metavariables_00_01tmpl_1_1list_3_05216f3256a498cdc6e28f87f21b55216.html#a8b6246a999712921ce06122117b772a3">AlgorithmImpl&lt; ParallelComponent, ChareType, Metavariables, tmpl::list&lt; ActionsPack... &gt;, tmpl::list&lt; InboxTagsPack... &gt;, ArrayIndex, InitialDataBox &gt;::get_terminate()</a>.</p>

</div>
</div>
<a id="ga0899b00614f1c47c6b32d1f83976a23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0899b00614f1c47c6b32d1f83976a23b">&#9670;&nbsp;</a></span>my_local_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Parallel::my_local_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The local index of my processing element on my node. This is in the interval 0, ..., procs_on_node(my_node()) - 1. </p>

</div>
</div>
<a id="ga9f24e1c6dfcfa4e9250a165973b1a524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f24e1c6dfcfa4e9250a165973b1a524">&#9670;&nbsp;</a></span>my_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Parallel::my_node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of my node. </p>

<p class="reference">Referenced by <a class="el" href="group__ErrorHandling.html#ga976ceeca531715395cf8b0cb9664fbc7">abort_with_error_message()</a>.</p>

</div>
</div>
<a id="ga9537d2f88bafe61b07e0ceda735243ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9537d2f88bafe61b07e0ceda735243ca">&#9670;&nbsp;</a></span>my_proc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Parallel::my_proc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of my processing element. </p>

<p class="reference">Referenced by <a class="el" href="group__ErrorHandling.html#ga976ceeca531715395cf8b0cb9664fbc7">abort_with_error_message()</a>.</p>

</div>
</div>
<a id="ga487910432c5ea8b35c12eb721c4afabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga487910432c5ea8b35c12eb721c4afabe">&#9670;&nbsp;</a></span>new_reduction_msg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CkReductionMsg* Parallel::new_reduction_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParallel_1_1ReductionData.html">ReductionData</a>&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>reduction_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <code><a class="el" href="structParallel_1_1ReductionData.html" title="Used for reducing heterogeneous collection of types in a single reduction call. ">ReductionData</a></code> to a <code>CkReductionMsg</code>. Used in custom reducers. </p>
<h3>Example</h3>
<p>See the return statement of: </p><div class="fragment"><div class="line">CkReductionMsg* reduce_reduction_data(<span class="keyword">const</span> <span class="keywordtype">int</span> number_of_messages,</div><div class="line">                                      CkReductionMsg** <span class="keyword">const</span> msgs) {</div><div class="line">  <span class="comment">// clang-tidy: do not use pointer arithmetic</span></div><div class="line">  Parallel::ReductionData&lt;int, std::unordered_map&lt;std::string, int&gt;,</div><div class="line">                          <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;int&gt;</a>&gt;</div><div class="line">      reduced(msgs[0]);  <span class="comment">// NOLINT</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> msg_id = 1; msg_id &lt; number_of_messages; ++msg_id) {</div><div class="line">    <span class="comment">// clang-tidy: do not use pointer arithmetic</span></div><div class="line">    Parallel::ReductionData&lt;int, std::unordered_map&lt;std::string, int&gt;,</div><div class="line">                            <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;int&gt;</a>&gt;</div><div class="line">        current(msgs[msg_id]);  <span class="comment">// NOLINT</span></div><div class="line">    <span class="keywordflow">if</span> (Parallel::get&lt;0&gt;(current) != Parallel::get&lt;0&gt;(reduced)) {</div><div class="line">      <a class="code" href="group__Parallel.html#gaccc68e564135958d18110d2847dcc1b3">Parallel::abort</a>(<span class="stringliteral">&quot;Tried to reduce from different iteration values.&quot;</span>);</div><div class="line">    }</div><div class="line">    <span class="comment">// compute maximum of each value in an unordered_map</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; string_double : Parallel::get&lt;1&gt;(current)) {</div><div class="line">      <span class="keywordflow">if</span> (string_double.second &gt;</div><div class="line">          Parallel::get&lt;1&gt;(reduced)[string_double.first]) {</div><div class="line">        Parallel::get&lt;1&gt;(reduced)[string_double.first] = string_double.second;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="comment">// compute sum of each element in a vector</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="namespacetnsr.html#ac7a4fa718be18533f5e2727e09f10704">i</a> = 0; i &lt; Parallel::get&lt;2&gt;(current).<a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/iterator/size.html">size</a>(); ++<a class="code" href="namespacetnsr.html#ac7a4fa718be18533f5e2727e09f10704">i</a>) {</div><div class="line">      Parallel::get&lt;2&gt;(reduced)[<a class="code" href="namespacetnsr.html#ac7a4fa718be18533f5e2727e09f10704">i</a>] += Parallel::get&lt;2&gt;(current)[<a class="code" href="namespacetnsr.html#ac7a4fa718be18533f5e2727e09f10704">i</a>];</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__Parallel.html#ga487910432c5ea8b35c12eb721c4afabe">Parallel::new_reduction_msg</a>(reduced);</div><div class="line">}</div></div><!-- fragment -->
</div>
</div>
<a id="ga042f8935c6008898b980065058d0d8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga042f8935c6008898b980065058d0d8e2">&#9670;&nbsp;</a></span>node_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Parallel::node_of </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>proc_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of the node for the given processing element. </p>

</div>
</div>
<a id="gaf999b9700ece84fca6cb82bb1ee9f3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf999b9700ece84fca6cb82bb1ee9f3f2">&#9670;&nbsp;</a></span>number_of_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Parallel::number_of_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of nodes. </p>

</div>
</div>
<a id="ga537d2cc78336566826c93c49f82746a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga537d2cc78336566826c93c49f82746a8">&#9670;&nbsp;</a></span>number_of_procs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Parallel::number_of_procs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of processing elements. </p>

<p class="reference">Referenced by <a class="el" href="classInformer.html#a8cc4c48811fe91eb783f490044f2ef2b">Informer::print_startup_info()</a>.</p>

</div>
</div>
<a id="gae21964b5d28608afd21ae090c1c4c073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae21964b5d28608afd21ae090c1c4c073">&#9670;&nbsp;</a></span>printf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::printf </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an atomic message to stdout with C printf usage. </p>
<p>Similar to Python, you can print any object that's streamable by passing it in as an argument and using the formatter "%s". For example, </p><div class="fragment"><div class="line"><a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a> <a class="code" href="namespacetnsr.html#a2fda2cdde3d605b04b814e6efa6339b5">a</a>{0.8, 73, 9.8};</div><div class="line"><a class="code" href="group__Parallel.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a>(<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="namespacetnsr.html#a2fda2cdde3d605b04b814e6efa6339b5">a</a>);</div></div><!-- fragment --> 
<p class="reference">References <a class="el" href="group__ErrorHandling.html#ga15999710b74a2bb739b0273bf1bc7b7b">disable_floating_point_exceptions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__FileSystem.html#gab9e523e13e2f581bc4c27372e1f18153">file_system::create_directory()</a>, <a class="el" href="classParallel_1_1Main.html#ad31bce8155c9f055625469506748204f">Parallel::Main&lt; Metavariables &gt;::Main()</a>, <a class="el" href="classInformer.html#a43fced4a7f0c6a6b2db19869791bf60b">Informer::print_exit_info()</a>, and <a class="el" href="classInformer.html#a8cc4c48811fe91eb783f490044f2ef2b">Informer::print_startup_info()</a>.</p>

</div>
</div>
<a id="gab9459395dbb2a65f0d0b0439387067a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9459395dbb2a65f0d0b0439387067a1">&#9670;&nbsp;</a></span>procs_on_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Parallel::procs_on_node </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of processing elements on the given node. </p>

</div>
</div>
<a id="gaf46b590510bd8fad34c7055079262707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf46b590510bd8fad34c7055079262707">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;char&gt; serialize </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize an object using PUP. </p>
<p>The type to serialize as must be explicitly specified. We require this because a mismatch between the serialize and deserialize calls causes undefined behavior and we do not want this to depend on inferred types for safety.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to serialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b5b8d712c472935e5c817e9ed723c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b5b8d712c472935e5c817e9ed723c25">&#9670;&nbsp;</a></span>try_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parallel::try_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CmiNodeLock *&gt;&#160;</td>
          <td class="paramname"><em>node_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the lock was successfully acquired and false if the lock is already acquired by another processor. </p>

</div>
</div>
<a id="ga26e5eb4933e796cd454b67ac773836f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26e5eb4933e796cd454b67ac773836f9">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::unlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CmiNodeLock *&gt;&#160;</td>
          <td class="paramname"><em>node_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock a converse CmiNodeLock. </p>

<p class="reference">References <a class="el" href="group__DataBoxGroup.html#ga18ab344b7599c78f3866fd2d2bb4687c">db::apply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAlgorithmImpl_3_01ParallelComponent_00_01ChareType_00_01Metavariables_00_01tmpl_1_1list_3_05216f3256a498cdc6e28f87f21b55216.html#a8b6246a999712921ce06122117b772a3">AlgorithmImpl&lt; ParallelComponent, ChareType, Metavariables, tmpl::list&lt; ActionsPack... &gt;, tmpl::list&lt; InboxTagsPack... &gt;, ArrayIndex, InitialDataBox &gt;::get_terminate()</a>.</p>

</div>
</div>
<a id="ga62feba0b73433140761dad9a3127b998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62feba0b73433140761dad9a3127b998">&#9670;&nbsp;</a></span>wall_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Parallel::wall_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current wall time in seconds. </p>

<p class="reference">Referenced by <a class="el" href="classAlgorithmImpl_3_01ParallelComponent_00_01ChareType_00_01Metavariables_00_01tmpl_1_1list_3_05216f3256a498cdc6e28f87f21b55216.html#a8b6246a999712921ce06122117b772a3">AlgorithmImpl&lt; ParallelComponent, ChareType, Metavariables, tmpl::list&lt; ActionsPack... &gt;, tmpl::list&lt; InboxTagsPack... &gt;, ArrayIndex, InitialDataBox &gt;::get_terminate()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
